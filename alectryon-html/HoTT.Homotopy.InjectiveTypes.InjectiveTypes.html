<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>InjectiveTypes.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** * Injective Types *)</span>

<span class="sd">(** Formalization of the paper: Injective Types in Univalent Mathematics by Mart√≠n Escard√≥ (with some extra results). *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core Truncations.Constant.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modalities.Modality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HFiber.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Universes.HProp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> ExcludedMiddle.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> InjectiveTypes.TypeFamKanExt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Definitions of injectivity and first examples *)</span>

<span class="sd">(** Since the universe levels are important to many of the results here, we keep track of them explicitly as much as possible. Due to our inability to use the max and successor operations within proofs, we instead construct these universes and their associated posetal relations in the arguments of the functions.</span>

<span class="sd">In universe declarations, we use [u], [v], [w], etc. as our typical universe variables. Our convention for the max of two universes [u] and [v] is [uv], and the successor of a universe [u] is [su]. Occasionally we write [T] for a top universe which is strictly larger than all other provided universes.</span>

<span class="sd">We hope that later versions of Coq will allow us access to the max and successor operations and much of the cumbersome universe handling here can be greatly reduced. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">UniverseStructure</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">Universes u v w uv uw vw.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Constraint</span> <span class="nf">u</span> &lt;= uv, v &lt;= uv, u &lt;= uw, w &lt;= uw, v &lt;= vw, w &lt;= vw.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A type [D] is said to be injective if for every embedding [j : X -&gt; Y] and every function [f : X -&gt; D], there merely exists a [f&#39; : Y -&gt; D] such that [f&#39; o j == f]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">IsInjectiveType</span>@{uvw | uv &lt;= uvw, uw &lt;= uvw, vw &lt;= uvw} (D : <span class="kt">Type</span>@{w})
    := <span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>@{u}) (<span class="nv">Y</span> : <span class="kt">Type</span>@{v}) (<span class="nv">j</span> : X -&gt; Y) (<span class="nv">isem</span> : IsEmbedding@{u v uv} j)
      (<span class="nv">f</span> : X -&gt; D), merely@{uvw} (sig@{vw uw} (<span class="kr">fun</span> <span class="nv">f&#39;</span> =&gt; f&#39; o j == f)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A type is then algebraically injective if the same is true, but without the propositional truncation. We use a class here instead of just a sigma type to make proofs more readable. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsAlgebraicInjectiveType</span>@{} (D : <span class="kt">Type</span>@{w}) := {
    lift_ai {X : <span class="kt">Type</span>@{u}} {Y : <span class="kt">Type</span>@{v}} (j : X -&gt; Y) {isem : IsEmbedding@{u v uv} j} (f : X -&gt; D)
      : Y -&gt; D;
    is_ext_ai {X : <span class="kt">Type</span>@{u}} {Y : <span class="kt">Type</span>@{v}} (j : X -&gt; Y) {isem} f
      : lift_ai j f o j == f;
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Contractible types are algebraically injective. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk1">#[export] <span class="kn">Instance</span> <span class="nf">alg_inj_contr</span>@{} (D : <span class="kt">Type</span>@{w}) (cD : Contr D)
    : IsAlgebraicInjectiveType@{} D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>cD</var><span class="hyp-type"><b>: </b><span>Contr D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>cD</var><span class="hyp-type"><b>: </b><span>Contr D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk3">snapply Build_IsAlgebraicInjectiveType; <span class="nb">intros</span> X Y j isem f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>cD</var><span class="hyp-type"><b>: </b><span>Contr D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; D</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>cD</var><span class="hyp-type"><b>: </b><span>Contr D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chk4"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y) 
   (<span class="nv">isem</span> : IsEmbedding j) 
   (<span class="nv">f</span> : X -&gt; D) =&gt; <span class="nl">?Goal</span>) X Y j
  (istruncmap_mapinO_tr j) f o j == f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>cD</var><span class="hyp-type"><b>: </b><span>Contr D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; D</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (const (center D)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>cD</var><span class="hyp-type"><b>: </b><span>Contr D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y) (<span class="nv">_</span> : IsEmbedding j)
   (<span class="nv">_</span> : X -&gt; D) =&gt; const (center D)) X Y j
  (istruncmap_mapinO_tr j) f o j == f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk7"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>cD</var><span class="hyp-type"><b>: </b><span>Contr D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">const (center D) (j x) = f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (contr _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** [Empty] is not algebraically injective. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk8"><span class="kn">Definition</span> <span class="nf">not_alg_inj_empty</span>@{}
    : IsAlgebraicInjectiveType@{} Empty -&gt; Empty.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType Empty -&gt; Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType Empty -&gt; Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chka"><span class="nb">intros</span> Eai.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Eai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType Empty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkb"><span class="nb">refine</span> (lift_ai (Empty_rec@{v}) idmap tt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Eai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType Empty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding Empty_rec</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkc"><span class="nb">apply</span> istruncmap_mapinO_tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Eai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType Empty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr (-<span class="mi">1</span>)) Empty_rec</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply mapinO_between_inO@{uv u v uv}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">UniverseStructure</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [Type@{uv}] is algebraically [u],[v]-injective in at least two ways. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkd"><span class="kn">Definition</span> <span class="nf">alg_inj_Type_sigma</span>@{u v uv suv | u &lt;= uv, v &lt;= uv, uv &lt; suv} `{Univalence}
  : IsAlgebraicInjectiveType@{u v suv uv suv suv} <span class="kt">Type</span>@{uv}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkf">snapply Build_IsAlgebraicInjectiveType; <span class="nb">intros</span> X Y j isem f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chk10"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y) 
   (<span class="nv">isem</span> : IsEmbedding j) 
   (<span class="nv">f</span> : X -&gt; <span class="kt">Type</span>) =&gt; <span class="nl">?Goal</span>) X Y j
  (istruncmap_mapinO_tr j) f o j == f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk11">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (f &lt;| j).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y) (<span class="nv">_</span> : IsEmbedding j)
   (<span class="nv">f</span> : X -&gt; <span class="kt">Type</span>) =&gt; f &lt;| j) X Y j
  (istruncmap_mapinO_tr j) f o j == f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk13"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f &lt;| j) (j x) = f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply isext_leftkanfam.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk14"><span class="kn">Instance</span> <span class="nf">alg_inj_Type_forall</span>@{u v uv suv | u &lt;= uv, v &lt;= uv, uv &lt; suv} `{Univalence}
  : IsAlgebraicInjectiveType@{u v suv uv suv suv} <span class="kt">Type</span>@{uv}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk16">snapply Build_IsAlgebraicInjectiveType; <span class="nb">intros</span> X Y j isem f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chk17" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chk17"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y) 
   (<span class="nv">isem</span> : IsEmbedding j) 
   (<span class="nv">f</span> : X -&gt; <span class="kt">Type</span>) =&gt; <span class="nl">?Goal</span>) X Y j
  (istruncmap_mapinO_tr j) f o j == f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk18">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (f |&gt; j).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk19">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y) (<span class="nv">_</span> : IsEmbedding j)
   (<span class="nv">f</span> : X -&gt; <span class="kt">Type</span>) =&gt; f |&gt; j) X Y j
  (istruncmap_mapinO_tr j) f o j == f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk1a"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f |&gt; j) (j x) = f x</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply isext_rightkanfam.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Constructions with algebraically injective types *)</span>

<span class="sd">(** Retracts of algebraically injective types are algebraically injective. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk1b"><span class="kn">Definition</span> <span class="nf">alg_inj_retract</span>
  @{u v w w&#39; uv uw vw uw&#39; vw&#39;
  | u &lt;= uv, v &lt;= uv, u &lt;= uw, w &lt;= uw, v &lt;= vw, w &lt;= vw, u &lt;= uw&#39;, v &lt;= vw&#39;, w&#39; &lt;= uw&#39;, w&#39; &lt;= vw&#39;}
  {D&#39; : <span class="kt">Type</span>@{w&#39;}} {D : <span class="kt">Type</span>@{w}} (r : D -&gt; D&#39;) {s : D&#39; -&gt; D}
  (retr : r o s == idmap) (Dai : IsAlgebraicInjectiveType@{u v w uv uw vw} D)
  : IsAlgebraicInjectiveType@{u v w&#39; uv uw&#39; vw&#39;} D&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk1d">snapply Build_IsAlgebraicInjectiveType; <span class="nb">intros</span> X Y j isem f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; D&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chk1e"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y) 
   (<span class="nv">isem</span> : IsEmbedding j) 
   (<span class="nv">f</span> : X -&gt; D&#39;) =&gt; <span class="nl">?Goal</span>) X Y j
  (istruncmap_mapinO_tr j) f o j == f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk1f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; D&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (r o lift_ai _ (s o f)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y) (<span class="nv">isem</span> : IsEmbedding j)
   (<span class="nv">f</span> : X -&gt; D&#39;) =&gt; r o lift_ai j (s o f)) X Y j
  (istruncmap_mapinO_tr j) f o j == f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk21"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r (lift_ai j (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (f x)) (j x)) = f x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk22">rhs_V <span class="nb">apply</span> (retr (f x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r (lift_ai j (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (f x)) (j x)) =
r (s (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap r (is_ext_ai _ (s o f) x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">UniverseStructure</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">Universes u v w t uv uw vw tw utw vtw.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Constraint</span> <span class="nf">u</span> &lt;= uv, u &lt;= uw, v &lt;= vw, v &lt;= uv, w &lt;= uw, w &lt;= vw, w &lt;= tw, t &lt;= tw,
    uw &lt;= utw, vw &lt;= vtw, tw &lt;= utw, tw &lt;= vtw.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Dependent products are algebraically injective when all their factors are. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk23">#[export] <span class="kn">Instance</span> <span class="nf">alg_inj_forall</span>@{}
    `{Funext} {A : <span class="kt">Type</span>@{t}} (D : A -&gt; <span class="kt">Type</span>@{w})
    (Dai : <span class="kr">forall</span> <span class="nv">a</span>, IsAlgebraicInjectiveType@{u v w uv uw vw} (D a))
    : IsAlgebraicInjectiveType@{u v tw uv utw vtw} (<span class="kr">forall</span> <span class="nv">a</span>, D a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsAlgebraicInjectiveType (D a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType (<span class="kr">forall</span> <span class="nv">a</span> : A, D a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk24"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsAlgebraicInjectiveType (D a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType (<span class="kr">forall</span> <span class="nv">a</span> : A, D a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk25">snapply Build_IsAlgebraicInjectiveType; <span class="nb">intros</span> X Y j isem f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsAlgebraicInjectiveType (D a)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, D a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, D a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chk26" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsAlgebraicInjectiveType (D a)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, D a</span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chk26"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y) 
   (<span class="nv">isem</span> : IsEmbedding j) 
   (<span class="nv">f</span> : X -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, D a) =&gt; 
 <span class="nl">?Goal</span>) X Y j (istruncmap_mapinO_tr j) f o j == f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk27">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsAlgebraicInjectiveType (D a)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, D a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, D a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">y</span> <span class="nv">a</span> =&gt; lift_ai _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x a) y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk28">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsAlgebraicInjectiveType (D a)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, D a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y) (<span class="nv">isem</span> : IsEmbedding j)
   (<span class="nv">f</span> : X -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, D a) (<span class="nv">y</span> : Y) (<span class="nv">a</span> : A) =&gt;
 lift_ai j (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f x a) y) X Y j
  (istruncmap_mapinO_tr j) f o j == f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk29"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsAlgebraicInjectiveType (D a)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, D a</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; lift_ai j (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f x a) (j x)) =
f x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk2a">funext a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsAlgebraicInjectiveType (D a)</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kr">forall</span> <span class="nv">a</span> : A, D a</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lift_ai j (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f x a) (j x) = f x a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (is_ext_ai _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x a) x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** In particular, exponentials of algebraically injective types are algebraically injective. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">alg_inj_arrow</span>@{}
    `{Funext} {A : <span class="kt">Type</span>@{t}} {D : <span class="kt">Type</span>@{w}}
    (Dai : IsAlgebraicInjectiveType@{u v w uv uw vw} D)
    : IsAlgebraicInjectiveType@{u v tw uv utw vtw} (A -&gt; D)
    := _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">UniverseStructure</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Algebraically injective types are retracts of any type that they embed into. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">retract_alg_inj_embedding</span>@{v w vw | v &lt;= vw, w &lt;= vw}
  (D : <span class="kt">Type</span>@{w}) {Y : <span class="kt">Type</span>@{v}} (j : D -&gt; Y) (isem : IsEmbedding j)
  (Dai : IsAlgebraicInjectiveType@{w v w vw w vw} D)
  : { r : Y -&gt; D &amp; r o j == idmap }
  := (lift_ai _ idmap; is_ext_ai _ idmap).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any algebraically [u],[su]-injective type [X : Type@{u}], is a retract of [X -&gt; Type@{u}]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">retract_power_universe_alg_usuinj</span>@{u su | u &lt; su} `{Univalence}
  (D : <span class="kt">Type</span>@{u}) (Dai : IsAlgebraicInjectiveType@{u su u su u su} D)
  : { r : (D -&gt; <span class="kt">Type</span>@{u}) -&gt; D &amp; r o (@paths D) == idmap }
  := retract_alg_inj_embedding D (@paths D) isembedding_paths Dai.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Algebraic flabbiness and resizing constructions *)</span>
<span class="sd">(** If [D : Type@{u}] is algebraically [u],[su]-injective, then it is algebraically [u],[u]-injective. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk2b"><span class="kn">Definition</span> <span class="nf">alg_uuinj_alg_usu_inj</span>
  @{u w su uw suw
  | u &lt; su, u &lt;= uw, w &lt;= uw, su &lt;= suw, w &lt;= suw}
  (D : <span class="kt">Type</span>@{w}) (Dai : IsAlgebraicInjectiveType@{u su w su uw suw} D)
  : IsAlgebraicInjectiveType@{u u w u uw uw} D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk2c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk2d">snapply Build_IsAlgebraicInjectiveType.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y),
IsEmbedding j -&gt; (X -&gt; D) -&gt; Y -&gt; D</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chk2e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y)
(<span class="nv">isem</span> : MapIn (Tr (-<span class="mi">1</span>)) j) (<span class="nv">f</span> : X -&gt; D),
<span class="nl">?lift_ai</span> X Y j (istruncmap_mapinO_tr j) f o j == f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk2f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y),
IsEmbedding j -&gt; (X -&gt; D) -&gt; Y -&gt; D</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@lift_ai D Dai).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y)
(<span class="nv">isem</span> : MapIn (Tr (-<span class="mi">1</span>)) j) (<span class="nv">f</span> : X -&gt; D),
(<span class="kr">fun</span> <span class="nv">X0</span> <span class="nv">Y0</span> : <span class="kt">Type</span> =&gt; lift_ai) X Y j
  (istruncmap_mapinO_tr j) f o j == f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@is_ext_ai D Dai).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** Note that this proof is easy because of cumulativity of [Type] (which is not assumed in the original paper). *)</span>

<span class="sd">(** Algebraic flabbiness is a variant of algebraic injectivity, but only ranging over embeddings of propositions into the unit type. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsAlgebraicFlabbyType</span>@{u w} (D : <span class="kt">Type</span>@{w}) := {
  center_af {P : HProp@{u}} (f : P -&gt; D) : D;
  contr_af {P : HProp@{u}} (f : P -&gt; D) (p : P) : center_af f = f p;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Algebraic flabbiness of a type [D] is equivalent to the statement that all conditionally constant functions [X -&gt; D] are constant. First we give the condition, and then the two implications. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cconst_is_const_cond</span>@{u w uw | u &lt;= uw, w &lt;= uw}
  (D : <span class="kt">Type</span>@{w})
  := <span class="kr">forall</span> (<span class="nv">X</span> : <span class="kt">Type</span>@{u}) (<span class="nv">f</span> : X -&gt; D),
    ConditionallyConstant@{u w uw} f -&gt; sig@{uw uw} (<span class="kr">fun</span> <span class="nv">d</span> =&gt; <span class="kr">forall</span> <span class="nv">x</span>, d = f x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk31"><span class="kn">Definition</span> <span class="nf">alg_flab_cconst_is_const</span>@{u w uw | u &lt;= uw, w &lt;= uw}
  (D : <span class="kt">Type</span>@{w}) (ccond : cconst_is_const_cond@{u w uw} D)
  : IsAlgebraicFlabbyType@{u w} D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ccond</var><span class="hyp-type"><b>: </b><span>cconst_is_const_cond D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk32"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ccond</var><span class="hyp-type"><b>: </b><span>cconst_is_const_cond D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk33">snapply Build_IsAlgebraicFlabbyType; <span class="nb">intros</span> P f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ccond</var><span class="hyp-type"><b>: </b><span>cconst_is_const_cond D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ccond</var><span class="hyp-type"><b>: </b><span>cconst_is_const_cond D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chk34"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : P,
(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">f</span> : P -&gt; D) =&gt; <span class="nl">?Goal</span>) P f = f p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk35">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ccond</var><span class="hyp-type"><b>: </b><span>cconst_is_const_cond D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk36"><span class="nb">apply</span> (ccond P f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ccond</var><span class="hyp-type"><b>: </b><span>cconst_is_const_cond D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ConditionallyConstant f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk37"><span class="nb">apply</span> (cconst_factors_hprop _ _ idmap f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ccond</var><span class="hyp-type"><b>: </b><span>cconst_is_const_cond D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : P =&gt; f x) == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk38">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>ccond</var><span class="hyp-type"><b>: </b><span>cconst_is_const_cond D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : P,
(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">f</span> : P -&gt; D) =&gt;
 <span class="kr">let</span> <span class="nv">X</span> :=
   <span class="kr">fun</span> <span class="nv">H</span> : ConditionallyConstant f =&gt; (ccond P f H).<span class="mi">1</span>
   <span class="kr">in</span>
 X
   (cconst_factors_hprop f P idmap f (<span class="kr">fun</span> <span class="nv">x0</span> : P =&gt; <span class="mi">1</span>)))
  P f = f p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (ccond P f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk39"><span class="kn">Definition</span> <span class="nf">cconst_is_const_alg_flab</span>@{u w uw | u &lt;= uw, w &lt;= uw}
  (D : <span class="kt">Type</span>@{w}) (Daf : IsAlgebraicFlabbyType@{u w} D)
  : cconst_is_const_cond@{u w uw} D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cconst_is_const_cond D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cconst_is_const_cond D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk3b"><span class="nb">intros</span> X f [f&#39; e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>Trunc (-<span class="mi">1</span>) X -&gt; D</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f&#39; (tr x) = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{d : D &amp; <span class="kr">forall</span> <span class="nv">x</span> : X, d = f x}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk3c">srefine (center_af f&#39;; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>Trunc (-<span class="mi">1</span>) X -&gt; D</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f&#39; (tr x) = f x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">d</span> : D =&gt; <span class="kr">forall</span> <span class="nv">x</span> : X, d = f x) (center_af f&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk3d"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>Trunc (-<span class="mi">1</span>) X -&gt; D</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : X, f&#39; (tr x) = f x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">center_af f&#39; = f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (contr_af f&#39; (tr x) @ e x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Algebraic flabbiness is equivalent to algebraic injectivity, with appropriate choices of universes. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">UniverseStructure</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">Universes u v w uv uw vw.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Constraint</span> <span class="nf">u</span> &lt;= uv, v &lt;= uv, u &lt;= uw, w &lt;= uw, v &lt;= vw, w &lt;= vw.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Algebraically [u],[v]-injective types are algebraically [u]-flabby. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk3e"><span class="kn">Definition</span> <span class="nf">alg_flab_alg_inj</span>@{}
    {D : <span class="kt">Type</span>@{w}} (Dai : IsAlgebraicInjectiveType@{u v w uv uw vw} D)
    : IsAlgebraicFlabbyType@{u w} D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk3f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk40">snapply Build_IsAlgebraicFlabbyType; <span class="nb">intros</span> P f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chk41"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : P,
(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">f</span> : P -&gt; D) =&gt; <span class="nl">?Goal</span>) P f = f p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk42">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">srapply (lift_ai _ f tt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk43">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : P,
(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">f</span> : P -&gt; D) =&gt;
 lift_ai (<span class="kr">fun</span> <span class="nv">_</span> : P =&gt; <span class="nl">?y</span>) f tt) P f = f p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> is_ext_ai.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Algebraically [uv]-flabby types are algebraically [u],[v]-injective. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk44"><span class="kn">Definition</span> <span class="nf">alg_inj_alg_flab</span>@{}
    {D : <span class="kt">Type</span>@{w}} (Daf : IsAlgebraicFlabbyType@{uv w} D)
    : IsAlgebraicInjectiveType@{u v w uv uw vw} D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk45"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk46">snapply Build_IsAlgebraicInjectiveType; <span class="nb">intros</span> X Y j isem f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; D</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chk47" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chk47"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y) 
   (<span class="nv">isem</span> : IsEmbedding j) 
   (<span class="nv">f</span> : X -&gt; D) =&gt; <span class="nl">?Goal</span>) X Y j
  (istruncmap_mapinO_tr j) f o j == f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk48">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Y -&gt; D</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk49"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (center_af (<span class="kr">fun</span> <span class="nv">x</span> : Build_HProp (hfiber j y) =&gt; f x.<span class="mi">1</span>)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk4a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">j</span> : X -&gt; Y) (<span class="nv">isem</span> : IsEmbedding j)
   (<span class="nv">f</span> : X -&gt; D) (<span class="nv">y</span> : Y) =&gt;
 center_af (<span class="kr">fun</span> <span class="nv">x</span> : Build_HProp (hfiber j y) =&gt; f x.<span class="mi">1</span>))
  X Y j (istruncmap_mapinO_tr j) f o j == f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk4b"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>MapIn (Tr (-<span class="mi">1</span>)) j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">center_af
  (<span class="kr">fun</span> <span class="nv">x</span> : Build_HProp (hfiber j (j x)) =&gt; f x.<span class="mi">1</span>) =
f x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (contr_af _ (x; idpath (j x))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">UniverseStructure</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** By combining the above, we see that if [D] is algebraically [ut],[v]-injective, then it is algebraically [u],[t]-injective. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk4c"><span class="kn">Definition</span> <span class="nf">resize_alg_inj</span>
  @{u v w t ut uw vw tw uvt utw
  | u &lt;= ut, u &lt;= uw, v &lt;= vw, v &lt;= uvt, w &lt;= uw, w &lt;= vw, w &lt;= tw,
    t &lt;= ut, t &lt;= tw, ut &lt;= uvt, ut &lt;= utw, uw &lt;= utw, tw &lt;= utw}
  {D : <span class="kt">Type</span>@{w}} (Dai : IsAlgebraicInjectiveType@{ut v w uvt utw vw} D)
  : IsAlgebraicInjectiveType@{u t w ut uw tw} D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk4d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk4e"><span class="nb">apply</span> alg_inj_alg_flab.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (alg_flab_alg_inj Dai).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We include two direct proofs of the algebraic flabbiness of [Type], instead of combining [alg_inj_alg_flab] with the previous proofs of algebraic injectivity, for better computations later. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk4f"><span class="kn">Definition</span> <span class="nf">alg_flab_Type_sigma</span>@{u su | u &lt; su} `{Univalence}
  : IsAlgebraicFlabbyType@{u su} <span class="kt">Type</span>@{u}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk50"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk51">snapply Build_IsAlgebraicFlabbyType; <span class="nb">intros</span> P A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>P -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>P -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chk52"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : P,
(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">A</span> : P -&gt; <span class="kt">Type</span>) =&gt; <span class="nl">?Goal</span>) P A = A p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk53">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>P -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (sig@{u u} (<span class="kr">fun</span> <span class="nv">p</span> =&gt; A p)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk54">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>P -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : P,
(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">A</span> : P -&gt; <span class="kt">Type</span>) =&gt; {p0 : P &amp; A p0}) P
  A = A p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk55"><span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>P -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">A</span> : P -&gt; <span class="kt">Type</span>) =&gt; {p : P &amp; A p}) P A =
A p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk56"><span class="nb">apply</span> path_universe_uncurried.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>P -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : P &amp; A p} &lt;~&gt; A p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@equiv_contr_sigma _ _ (contr_inhabited_hprop _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk57"><span class="kn">Instance</span> <span class="nf">alg_flab_Type_forall</span>@{u su | u &lt; su} `{Univalence}
  : IsAlgebraicFlabbyType@{u su} <span class="kt">Type</span>@{u}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk58"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk59">snapply Build_IsAlgebraicFlabbyType; <span class="nb">intros</span> P A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>P -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>P -&gt; <span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chk5a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : P,
(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">A</span> : P -&gt; <span class="kt">Type</span>) =&gt; <span class="nl">?Goal</span>) P A = A p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk5b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>P -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">forall</span> <span class="nv">p</span> : P, A p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk5c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>P -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : P,
(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">A</span> : P -&gt; <span class="kt">Type</span>) =&gt;
 <span class="kr">forall</span> <span class="nv">p0</span> : P, A p0) P A = A p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk5d"><span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>P -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">A</span> : P -&gt; <span class="kt">Type</span>) =&gt; <span class="kr">forall</span> <span class="nv">p</span> : P, A p)
  P A = A p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk5e"><span class="nb">apply</span> path_universe_uncurried.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>P -&gt; <span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">p</span> : P, A p) &lt;~&gt; A p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@equiv_contr_forall _ _ (contr_inhabited_hprop _ _) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Algebraic flabbiness with resizing axioms *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">AssumePropResizing</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{PropResizing}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Algebraic flabbiness is independent of universes under propositional resizing. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk5f"><span class="kn">Definition</span> <span class="nf">universe_independent_alg_flab</span>@{v u w}
    {D : <span class="kt">Type</span>@{w}} (Daf : IsAlgebraicFlabbyType@{v w} D)
    : IsAlgebraicFlabbyType@{u w} D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk60"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk61">snapply Build_IsAlgebraicFlabbyType; <span class="nb">intros</span> P f;
    <span class="nb">pose</span> (e := (equiv_smalltype@{v u} P));
    <span class="nb">pose</span> (PropQ := (@istrunc_equiv_istrunc _ _ e^-<span class="mi">1</span> (-<span class="mi">1</span>) _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>equiv_smalltype P</span></span><span class="hyp-type"><b>: </b><span>smalltype P &lt;~&gt; P</span></span></span></span><br><span><var>PropQ</var><span><span class="hyp-body"><b>:= </b><span>istrunc_equiv_istrunc P e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>IsHProp (smalltype P)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chk62" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>equiv_smalltype P</span></span><span class="hyp-type"><b>: </b><span>smalltype P &lt;~&gt; P</span></span></span></span><br><span><var>PropQ</var><span><span class="hyp-body"><b>:= </b><span>istrunc_equiv_istrunc P e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>IsHProp (smalltype P)</span></span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chk62"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : P,
(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">f</span> : P -&gt; D) =&gt;
 <span class="kr">let</span> <span class="nv">e</span> := equiv_smalltype P <span class="kr">in</span>
 <span class="kr">let</span> <span class="nv">PropQ</span> := istrunc_equiv_istrunc P e^-<span class="mi">1</span> <span class="kr">in</span> <span class="nl">?Goal</span>) P
  f = f p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk63">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>equiv_smalltype P</span></span><span class="hyp-type"><b>: </b><span>smalltype P &lt;~&gt; P</span></span></span></span><br><span><var>PropQ</var><span><span class="hyp-body"><b>:= </b><span>istrunc_equiv_istrunc P e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>IsHProp (smalltype P)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (center_af (f o e)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk64">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>equiv_smalltype P</span></span><span class="hyp-type"><b>: </b><span>smalltype P &lt;~&gt; P</span></span></span></span><br><span><var>PropQ</var><span><span class="hyp-body"><b>:= </b><span>istrunc_equiv_istrunc P e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>IsHProp (smalltype P)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : P,
(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">f</span> : P -&gt; D) =&gt;
 <span class="kr">let</span> <span class="nv">e</span> := equiv_smalltype P <span class="kr">in</span>
 <span class="kr">let</span> <span class="nv">PropQ</span> := istrunc_equiv_istrunc P e^-<span class="mi">1</span> <span class="kr">in</span>
 center_af (f o e)) P f = f p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk65"><span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>equiv_smalltype P</span></span><span class="hyp-type"><b>: </b><span>smalltype P &lt;~&gt; P</span></span></span></span><br><span><var>PropQ</var><span><span class="hyp-body"><b>:= </b><span>istrunc_equiv_istrunc P e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>IsHProp (smalltype P)</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">f</span> : P -&gt; D) =&gt;
 <span class="kr">let</span> <span class="nv">e</span> := equiv_smalltype P <span class="kr">in</span>
 <span class="kr">let</span> <span class="nv">PropQ</span> := istrunc_equiv_istrunc P e^-<span class="mi">1</span> <span class="kr">in</span>
 center_af (f o e)) P f = f p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk66">lhs <span class="nb">apply</span> (contr_af (f o e) (e^-<span class="mi">1</span> p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>equiv_smalltype P</span></span><span class="hyp-type"><b>: </b><span>smalltype P &lt;~&gt; P</span></span></span></span><br><span><var>PropQ</var><span><span class="hyp-body"><b>:= </b><span>istrunc_equiv_istrunc P e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>IsHProp (smalltype P)</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (e (e^-<span class="mi">1</span> p)) = f p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk67"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Daf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>equiv_smalltype P</span></span><span class="hyp-type"><b>: </b><span>smalltype P &lt;~&gt; P</span></span></span></span><br><span><var>PropQ</var><span><span class="hyp-body"><b>:= </b><span>istrunc_equiv_istrunc P e^-<span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>IsHProp (smalltype P)</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e (e^-<span class="mi">1</span> p) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Algebraic injectivity is independent of universes under propositional resizing. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk68"><span class="kn">Definition</span> <span class="nf">universe_independent_alg_inj</span>
    @{u v w u&#39; v&#39; uv uw vw u&#39;v&#39; u&#39;w v&#39;w
    | u &lt;= uv, v &lt;= uv, u &lt;= uw, w &lt;= uw, v &lt;= vw, w &lt;= vw,
      u&#39; &lt;= u&#39;v&#39;, v&#39; &lt;= u&#39;v&#39;, u&#39; &lt;= u&#39;w, w &lt;= u&#39;w, v&#39; &lt;= v&#39;w, w &lt;= v&#39;w}
    {D : <span class="kt">Type</span>@{w}} (Dai : IsAlgebraicInjectiveType@{u v w uv uw vw} D)
    : IsAlgebraicInjectiveType@{u&#39; v&#39; w u&#39;v&#39; u&#39;w v&#39;w} D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk69"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk6a"><span class="nb">apply</span> alg_inj_alg_flab.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk6b"><span class="nb">apply</span> universe_independent_alg_flab@{u u&#39;v&#39; w}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (alg_flab_alg_inj Dai).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Any algebraically injective type [D : Type@{u}] is a retract of [X -&gt; Type@{u}] with [X : Type@{u}]. This is a universe independent version of [retract_power_universe_alg_usuinj]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk6c"><span class="kn">Definition</span> <span class="nf">retract_power_universe_alg_inj</span>@{u su | u &lt; su} `{Univalence}
    {D : <span class="kt">Type</span>@{u}} (Dai : IsAlgebraicInjectiveType@{u u u u u u} D)
    : <span class="kr">exists</span> (<span class="nv">X</span> : <span class="kt">Type</span>@{u}) (<span class="nv">s</span> : D -&gt; (X -&gt; <span class="kt">Type</span>@{u})) (<span class="nv">r</span> : (X -&gt; <span class="kt">Type</span>@{u}) -&gt; D), r o s == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{X : <span class="kt">Type</span> &amp;
{s : D -&gt; X -&gt; <span class="kt">Type</span> &amp;
{r : (X -&gt; <span class="kt">Type</span>) -&gt; D &amp; r o s == idmap}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk6d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{X : <span class="kt">Type</span> &amp;
{s : D -&gt; X -&gt; <span class="kt">Type</span> &amp;
{r : (X -&gt; <span class="kt">Type</span>) -&gt; D &amp; r o s == idmap}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk6e"><span class="nb">refine</span> (D; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{s : D -&gt; D -&gt; <span class="kt">Type</span> &amp;
{r : (D -&gt; <span class="kt">Type</span>) -&gt; D &amp;
(<span class="kr">fun</span> <span class="nv">x</span> : D =&gt; r (s x)) == idmap}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk6f"><span class="nb">refine</span> (@paths D; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{r : (D -&gt; <span class="kt">Type</span>) -&gt; D &amp;
(<span class="kr">fun</span> <span class="nv">x</span> : D =&gt; r (paths x)) == idmap}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk70"><span class="nb">apply</span> (retract_power_universe_alg_usuinj D).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (universe_independent_alg_inj@{u u u u su u u u su u su} Dai).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">AssumePropResizing</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any retract of a type family [X -&gt; Type@{u}] is algebraically injective. This is the opposite result as above, classifying algebraically injective types, independent of universes. It should be noted that this direction of the if and only if does not depend on propositional resizing. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk71"><span class="kn">Definition</span> <span class="nf">alg_inj_retract_power_universe</span>@{u su | u &lt; su}
  `{Univalence} (D : <span class="kt">Type</span>@{u}) {X : <span class="kt">Type</span>@{u}} {s : D -&gt; (X -&gt; <span class="kt">Type</span>@{u})}
  (r : (X -&gt; <span class="kt">Type</span>@{u}) -&gt; D) (retr : r o s == idmap)
  : IsAlgebraicInjectiveType@{u u u u u u} D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>D, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D -&gt; X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(X -&gt; <span class="kt">Type</span>) -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk72"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>D, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D -&gt; X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(X -&gt; <span class="kt">Type</span>) -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk73"><span class="nb">apply</span> (alg_inj_retract r retr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>D, X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D -&gt; X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(X -&gt; <span class="kt">Type</span>) -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType (X -&gt; <span class="kt">Type</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply alg_inj_arrow.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Injectivity in terms of algebraic injectivity in the absence of resizing *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">UniverseStructure</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">Universes u v w uv uw vw uvw.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Constraint</span> <span class="nf">u</span> &lt;= uv, v &lt;= uv, u &lt;= uw, w &lt;= uw, v &lt;= vw, w &lt;= vw,
    uv &lt;= uvw, uw &lt;= uvw, vw &lt;= uvw.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Algebraically injective types are injective. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk74"><span class="kn">Definition</span> <span class="nf">inj_alg_inj</span>@{}
    (D : <span class="kt">Type</span>@{w}) (Dai : IsAlgebraicInjectiveType@{u v w uv uw vw} D)
    : IsInjectiveType@{u v w uv uw vw uvw} D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk75"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk76"><span class="nb">intros</span> X Y j isem f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely {f&#39; : Y -&gt; D &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk77"><span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f&#39; : Y -&gt; D &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (lift_ai _ _; is_ext_ai _ f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The propositional truncation of algebraic injectivity implies injectivity. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk78"><span class="kn">Definition</span> <span class="nf">inj_merely_alg_inj</span>@{T | uvw &lt; T}
    `{Funext} {D : <span class="kt">Type</span>@{w}}
    (mDai : merely@{T} (IsAlgebraicInjectiveType@{u v w uv uw vw} D))
    : ((IsInjectiveType@{u v w uv uw vw uvw} D) : <span class="kt">Type</span>@{T}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mDai</var><span class="hyp-type"><b>: </b><span>merely (IsAlgebraicInjectiveType D)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInjectiveType D : <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk79"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>mDai</var><span class="hyp-type"><b>: </b><span>merely (IsAlgebraicInjectiveType D)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInjectiveType D : <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk7a"><span class="nb">revert</span> mDai.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (IsAlgebraicInjectiveType D) -&gt;
IsInjectiveType D : <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk7b">napply Trunc_rec@{T T}. <span class="c">(* Manually stripping truncations so as to control universe variables. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsInjectiveType D)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chk7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chk7c"><hr></label><div class="goal-conclusion">IsAlgebraicInjectiveType D -&gt; IsInjectiveType D</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk7d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsInjectiveType D)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk7e"><span class="kp">repeat</span> (napply istrunc_forall@{T T T}; <span class="nb">intro</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D, a, a0</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>a -&gt; a0</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>IsEmbedding a1</span></span></span><br><span><var>a3</var><span class="hyp-type"><b>: </b><span>a -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp
  (merely
     {f&#39; : a0 -&gt; D &amp; (<span class="kr">fun</span> <span class="nv">x</span> : a =&gt; f&#39; (a1 x)) == a3})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> istrunc_truncation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk7f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D -&gt; IsInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk80"><span class="nb">intro</span> Dai.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Dai</var><span class="hyp-type"><b>: </b><span>IsAlgebraicInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inj_alg_inj@{} D Dai).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A retract of an injective type is injective. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk81"><span class="kn">Definition</span> <span class="nf">inj_retract</span>
    @{w&#39; uw&#39; vw&#39; uvw&#39; T
    | u &lt;= uw&#39;, v &lt;= vw&#39;, w&#39; &lt;= uw&#39;, w&#39; &lt;= vw&#39;, 
    uv &lt;= uvw&#39;, uw&#39; &lt;= uvw&#39;, vw&#39; &lt;= uvw&#39;, uvw &lt; T, uvw&#39; &lt; T}
    `{Funext} {D&#39; : <span class="kt">Type</span>@{w&#39;}} {D : <span class="kt">Type</span>@{w}} (r : D -&gt; D&#39;) {s : D&#39; -&gt; D}
    (retr : r o s == idmap) (Di : IsInjectiveType@{u v w uv uw vw uvw} D)
    : IsInjectiveType@{u v w&#39; uv uw&#39; vw&#39; uvw&#39;} D&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInjectiveType D&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk82"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInjectiveType D&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk83"><span class="nb">intros</span> X Y j isem f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely {f&#39; : Y -&gt; D&#39; &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk84"><span class="nb">specialize</span> (Di X Y j isem (s o f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>merely {f&#39; : Y -&gt; D &amp; f&#39; o j == s o f}</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely {f&#39; : Y -&gt; D&#39; &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk85"><span class="nb">revert</span> Di.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely {f&#39; : Y -&gt; D &amp; f&#39; o j == s o f} -&gt;
merely {f&#39; : Y -&gt; D&#39; &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk86">rapply Trunc_rec@{T T}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f&#39; : Y -&gt; D &amp;
(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (f x))} -&gt;
merely {f&#39; : Y -&gt; D&#39; &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk87"><span class="nb">intros</span> [g e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; D</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (j x)) == (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (f x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely {f&#39; : Y -&gt; D&#39; &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk88"><span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; D</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (j x)) == (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (f x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f&#39; : Y -&gt; D&#39; &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk89">snrefine (r o g; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; D</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (j x)) == (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (f x))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f&#39;</span> : Y -&gt; D&#39; =&gt; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f)
  (r o g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk8a"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; D</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (j x)) == (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (f x))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r (g (j x)) = f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk8b">rhs_V <span class="nb">apply</span> (retr (f x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>D', D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>D -&gt; D&#39;</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>D&#39; -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>r o s == idmap</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; D&#39;</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y -&gt; D</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; g (j x)) == (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; s (f x))</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r (g (j x)) = r (s (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap r (e x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">UniverseStructure</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Injective types are retracts of any type that they embed into, in an unspecified way. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">merely_retract_inj_embedding</span>@{v w vw svw | v &lt;= vw, w &lt;= vw, vw &lt; svw}
  (D : <span class="kt">Type</span>@{w}) {Y : <span class="kt">Type</span>@{v}} (j : D -&gt; Y) (isem : IsEmbedding j)
  (Di : IsInjectiveType@{w v w vw w vw vw} D)
  : merely@{svw} { r : Y -&gt; D &amp; r o j == idmap }
  := Di _ _ _ _ idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The power of an injective type is injective. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk8c"><span class="kn">Definition</span> <span class="nf">inj_arrow</span>
  @{u v w t uv ut vt tw uvt utw vtw utvw
  | u &lt;= uv, v &lt;= uv, u &lt;= ut, t &lt;= ut, v &lt;= vt, t &lt;= vt, t &lt;= tw, w &lt;= tw, uv &lt;= uvt, ut &lt;= uvt,
    vt &lt;= uvt, ut &lt;= utw, tw &lt;= utw, vt &lt;= vtw, tw &lt;= vtw, uvt &lt;= utvw, utw &lt;= utvw, vtw &lt;= utvw}
  `{Funext} {A : <span class="kt">Type</span>@{t}} (D : <span class="kt">Type</span>@{w})
  (Di : IsInjectiveType@{ut vt w uvt utw vtw utvw} D)
  : IsInjectiveType@{u v tw uv utw vtw utvw} (A -&gt; D).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInjectiveType (A -&gt; D)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk8d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInjectiveType (A -&gt; D)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk8e"><span class="nb">intros</span> X Y j isem f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely
  {f&#39; : Y -&gt; A -&gt; D &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk8f"><span class="nb">assert</span> (embId : IsEmbedding (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; a)) <span class="bp">by</span> rapply istruncmap_mapinO_tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A -&gt; D</span></span></span><br><span><var>embId</var><span class="hyp-type"><b>: </b><span>IsEmbedding idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely
  {f&#39; : Y -&gt; A -&gt; D &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk90"><span class="nb">pose proof</span> (mD := Di (X * A) (Y * A) (functor_prod j equiv_idmap)
    (istruncmap_functor_prod@{u v t t ut vt uvt uvt uv t} _ _ _) (uncurry f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A -&gt; D</span></span></span><br><span><var>embId</var><span class="hyp-type"><b>: </b><span>IsEmbedding idmap</span></span></span><br><span><var>mD</var><span class="hyp-type"><b>: </b><span>merely
  {f&#39; : Y * A -&gt; D &amp;
  f&#39; o functor_prod j <span class="mi">1</span>%equiv == uncurry f}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely
  {f&#39; : Y -&gt; A -&gt; D &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk91"><span class="nb">revert</span> mD.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A -&gt; D</span></span></span><br><span><var>embId</var><span class="hyp-type"><b>: </b><span>IsEmbedding idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely
  {f&#39; : Y * A -&gt; D &amp;
  f&#39; o functor_prod j <span class="mi">1</span>%equiv == uncurry f} -&gt;
merely
  {f&#39; : Y -&gt; A -&gt; D &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk92">rapply Trunc_rec@{utvw utvw}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A -&gt; D</span></span></span><br><span><var>embId</var><span class="hyp-type"><b>: </b><span>IsEmbedding idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f&#39; : Y * A -&gt; D &amp;
(<span class="kr">fun</span> <span class="nv">x</span> : X * A =&gt; f&#39; (functor_prod j <span class="mi">1</span>%equiv x)) ==
uncurry f} -&gt;
merely
  {f&#39; : Y -&gt; A -&gt; D &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk93"><span class="nb">intros</span> [g e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A -&gt; D</span></span></span><br><span><var>embId</var><span class="hyp-type"><b>: </b><span>IsEmbedding idmap</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y * A -&gt; D</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X * A =&gt; g (functor_prod j <span class="mi">1</span>%equiv x)) ==
uncurry f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely
  {f&#39; : Y -&gt; A -&gt; D &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk94"><span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A -&gt; D</span></span></span><br><span><var>embId</var><span class="hyp-type"><b>: </b><span>IsEmbedding idmap</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y * A -&gt; D</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X * A =&gt; g (functor_prod j <span class="mi">1</span>%equiv x)) ==
uncurry f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f&#39; : Y -&gt; A -&gt; D &amp; (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; f&#39; (j x)) == f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk95"><span class="nb">refine</span> (<span class="kr">fun</span> <span class="nv">y</span> <span class="nv">a</span> =&gt; g (y, a); _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A -&gt; D</span></span></span><br><span><var>embId</var><span class="hyp-type"><b>: </b><span>IsEmbedding idmap</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y * A -&gt; D</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X * A =&gt; g (functor_prod j <span class="mi">1</span>%equiv x)) ==
uncurry f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">x</span> : X) (<span class="nv">a</span> : A) =&gt; g (j x, a)) == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk96"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A -&gt; D</span></span></span><br><span><var>embId</var><span class="hyp-type"><b>: </b><span>IsEmbedding idmap</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y * A -&gt; D</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X * A =&gt; g (functor_prod j <span class="mi">1</span>%equiv x)) ==
uncurry f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; g (j x, a)) = f x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk97">funext a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>isem</var><span class="hyp-type"><b>: </b><span>IsEmbedding j</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; A -&gt; D</span></span></span><br><span><var>embId</var><span class="hyp-type"><b>: </b><span>IsEmbedding idmap</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>Y * A -&gt; D</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : X * A =&gt; g (functor_prod j <span class="mi">1</span>%equiv x)) ==
uncurry f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (j x, a) = f x a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (e (x, a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any [u],[su]-injective type [X : Type@{u}], is a retract of [X -&gt; Type@{u}] in an unspecified way. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">merely_retract_power_universe_inj</span>@{u su ssu | u &lt; su, su &lt; ssu}
  `{Univalence} (D : <span class="kt">Type</span>@{u}) (Di : IsInjectiveType@{u su u su u su su} D)
  : merely@{su} (sig@{su su} (<span class="kr">fun</span> <span class="nv">r</span> =&gt; r o (@paths D) == idmap))
  := merely_retract_inj_embedding D (@paths D) isembedding_paths Di.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Inverse of [inj_merely_alg_inj] modulo universes. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk98"><span class="kn">Definition</span> <span class="nf">merely_alg_inj_inj</span>@{u su ssu | u &lt; su, su &lt; ssu} `{Univalence}
  (D : <span class="kt">Type</span>@{u}) (Di : IsInjectiveType@{u su u su u su su} D)
  : merely@{su} (IsAlgebraicInjectiveType@{u u u u u u} D).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (IsAlgebraicInjectiveType D)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk99"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (IsAlgebraicInjectiveType D)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk9a">srefine (Trunc_functor (-<span class="mi">1</span>) _ (merely_retract_power_universe_inj D Di)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{r : (D -&gt; <span class="kt">Type</span>) -&gt; D &amp; r o paths == idmap} -&gt;
IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk9b"><span class="nb">intros</span> [r retr].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Di</var><span class="hyp-type"><b>: </b><span>IsInjectiveType D</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>(D -&gt; <span class="kt">Type</span>) -&gt; D</span></span></span><br><span><var>retr</var><span class="hyp-type"><b>: </b><span>(<span class="kr">fun</span> <span class="nv">x</span> : D =&gt; r (paths x)) == idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicInjectiveType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (alg_inj_retract_power_universe D r retr).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The equivalence of excluded middle with the (algebraic) injectivity of pointed types *)</span>

<span class="sd">(** Assuming excluded middle, all pointed types are algebraically flabby (and thus algebraically injective). *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk9c"><span class="kn">Definition</span> <span class="nf">alg_flab_pointed_lem</span>@{u w}
  `{ExcludedMiddle} {D : <span class="kt">Type</span>@{w}} (d : D)
  : IsAlgebraicFlabbyType@{u w} D.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk9d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chk9e">snapply Build_IsAlgebraicFlabbyType; <span class="nb">intros</span> P f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chk9f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chk9f"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : P,
(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">f</span> : P -&gt; D) =&gt; <span class="nl">?Goal</span>) P f = f p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chka0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chka1"><span class="nb">destruct</span> (LEM P _) <span class="kr">as</span> [p | np].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chka2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ P</span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chka2"><hr></label><div class="goal-conclusion">D</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chka3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (f p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chka4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> d.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chka5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : P,
(<span class="kr">fun</span> (<span class="nv">P</span> : HProp) (<span class="nv">f</span> : P -&gt; D) =&gt;
 <span class="kr">let</span> <span class="nv">s</span> := LEM P (trunctype_istrunc P) <span class="kr">in</span>
 <span class="kr">match</span> s <span class="kr">with</span>
 | inl t =&gt; (<span class="kr">fun</span> <span class="nv">p0</span> : P =&gt; f p0) t
 | inr n =&gt; (<span class="kr">fun</span> <span class="nv">_</span> : ~ P =&gt; d) n
 <span class="kr">end</span>) P f = f p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chka6"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p</span> : P,
<span class="kr">match</span> LEM P (trunctype_istrunc P) <span class="kr">with</span>
| inl t =&gt; f t
| inr _ =&gt; d
<span class="kr">end</span> = f p</div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chka7"><span class="nb">intros</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> LEM P (trunctype_istrunc P) <span class="kr">with</span>
| inl t =&gt; f t
| inr _ =&gt; d
<span class="kr">end</span> = f q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chka8"><span class="nb">destruct</span> (LEM P _) <span class="kr">as</span> [p | np].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>q, p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f p = f q</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chka9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ P</span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chka9"><hr></label><div class="goal-conclusion">d = f q</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkaa">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>q, p</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f p = f q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap f (path_ishprop _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkab">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>ExcludedMiddle</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>P -&gt; D</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>P</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>~ P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">d = f q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Empty_rec (np q)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If the type [P + ~P + Unit] is algebraically flabby for [P] a proposition, then [P] is decidable. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkac"><span class="kn">Definition</span> <span class="nf">decidable_alg_flab_hprop</span>@{w} `{Funext} (P : HProp@{w})
  (Paf : IsAlgebraicFlabbyType@{w w} ((P + ~P) + (Unit : <span class="kt">Type</span>@{w})))
  : Decidable P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Paf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType (P + ~ P + (Unit : <span class="kt">Type</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkad"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Paf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType (P + ~ P + (Unit : <span class="kt">Type</span>))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkae"><span class="nb">pose</span> (inl&#39; := inl : P + ~P -&gt; (P + ~P) + (Unit : <span class="kt">Type</span>@{w})).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Paf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType (P + ~ P + (Unit : <span class="kt">Type</span>))</span></span></span><br><span><var>inl'</var><span><span class="hyp-body"><b>:= </b><span>inl : P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span><span class="hyp-type"><b>: </b><span>P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkaf"><span class="nb">assert</span> (l : {d : (P + ~P) + (Unit : <span class="kt">Type</span>@{w}) &amp; <span class="kr">forall</span> <span class="nv">z</span>, d = inl&#39; z}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Paf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType (P + ~ P + (Unit : <span class="kt">Type</span>))</span></span></span><br><span><var>inl'</var><span><span class="hyp-body"><b>:= </b><span>inl : P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span><span class="hyp-type"><b>: </b><span>P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{d : P + ~ P + Unit &amp; <span class="kr">forall</span> <span class="nv">z</span> : P + ~ P, d = inl&#39; z}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chkb0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Paf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType (P + ~ P + (Unit : <span class="kt">Type</span>))</span></span></span><br><span><var>inl'</var><span><span class="hyp-body"><b>:= </b><span>inl : P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span><span class="hyp-type"><b>: </b><span>P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>{d : P + ~ P + (Unit : <span class="kt">Type</span>) &amp;
<span class="kr">forall</span> <span class="nv">z</span> : P + ~ P, d = inl&#39; z}</span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chkb0"><hr></label><div class="goal-conclusion">Decidable P</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkb1">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Paf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType (P + ~ P + (Unit : <span class="kt">Type</span>))</span></span></span><br><span><var>inl'</var><span><span class="hyp-body"><b>:= </b><span>inl : P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span><span class="hyp-type"><b>: </b><span>P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{d : P + ~ P + Unit &amp; <span class="kr">forall</span> <span class="nv">z</span> : P + ~ P, d = inl&#39; z}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkb2"><span class="nb">refine</span> (center_af _; contr_af inl&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Paf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType (P + ~ P + (Unit : <span class="kt">Type</span>))</span></span></span><br><span><var>inl'</var><span><span class="hyp-body"><b>:= </b><span>inl : P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span><span class="hyp-type"><b>: </b><span>P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (P + ~ P)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply ishprop_decidable_hprop@{w w}.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkb3">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Paf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType (P + ~ P + (Unit : <span class="kt">Type</span>))</span></span></span><br><span><var>inl'</var><span><span class="hyp-body"><b>:= </b><span>inl : P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span><span class="hyp-type"><b>: </b><span>P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>{d : P + ~ P + (Unit : <span class="kt">Type</span>) &amp;
<span class="kr">forall</span> <span class="nv">z</span> : P + ~ P, d = inl&#39; z}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkb4"><span class="nb">destruct</span> l <span class="kr">as</span> [[s | u] l2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Paf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType (P + ~ P + (Unit : <span class="kt">Type</span>))</span></span></span><br><span><var>inl'</var><span><span class="hyp-body"><b>:= </b><span>inl : P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span><span class="hyp-type"><b>: </b><span>P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>P + ~ P</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : P + ~ P, inl s = inl&#39; z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="injectivetypes-v-chkb5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Paf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType (P + ~ P + (Unit : <span class="kt">Type</span>))</span></span></span><br><span><var>inl'</var><span><span class="hyp-body"><b>:= </b><span>inl : P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span><span class="hyp-type"><b>: </b><span>P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : P + ~ P, inr u = inl&#39; z</span></span></span><br></div><label class="goal-separator" for="injectivetypes-v-chkb5"><hr></label><div class="goal-conclusion">Decidable P</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkb6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Paf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType (P + ~ P + (Unit : <span class="kt">Type</span>))</span></span></span><br><span><var>inl'</var><span><span class="hyp-body"><b>:= </b><span>inl : P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span><span class="hyp-type"><b>: </b><span>P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>P + ~ P</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : P + ~ P, inl s = inl&#39; z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> s.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkb7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Paf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType (P + ~ P + (Unit : <span class="kt">Type</span>))</span></span></span><br><span><var>inl'</var><span><span class="hyp-body"><b>:= </b><span>inl : P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span><span class="hyp-type"><b>: </b><span>P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : P + ~ P, inr u = inl&#39; z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkb8"><span class="nb">assert</span> (np := <span class="kr">fun</span> <span class="nv">p</span> =&gt; inl_ne_inr _ _ (l2 (inl p))^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Paf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType (P + ~ P + (Unit : <span class="kt">Type</span>))</span></span></span><br><span><var>inl'</var><span><span class="hyp-body"><b>:= </b><span>inl : P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span><span class="hyp-type"><b>: </b><span>P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : P + ~ P, inr u = inl&#39; z</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>P -&gt; Empty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkb9"><span class="nb">assert</span> (nnp := <span class="kr">fun</span> <span class="nv">np&#39;</span> =&gt; inl_ne_inr _ _ (l2 (inr np&#39;))^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>HProp</span></span></span><br><span><var>Paf</var><span class="hyp-type"><b>: </b><span>IsAlgebraicFlabbyType (P + ~ P + (Unit : <span class="kt">Type</span>))</span></span></span><br><span><var>inl'</var><span><span class="hyp-body"><b>:= </b><span>inl : P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span><span class="hyp-type"><b>: </b><span>P + ~ P -&gt; P + ~ P + (Unit : <span class="kt">Type</span>)</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>Unit</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">z</span> : P + ~ P, inr u = inl&#39; z</span></span></span><br><span><var>np</var><span class="hyp-type"><b>: </b><span>P -&gt; Empty</span></span></span><br><span><var>nnp</var><span class="hyp-type"><b>: </b><span>~ P -&gt; Empty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decidable P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Empty_rec (nnp np)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If all pointed types are algebraically flabby, then excluded middle holds. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkba"><span class="kn">Definition</span> <span class="nf">lem_pointed_types_alg_flab</span>@{w} `{Funext}
  (ptaf: <span class="kr">forall</span> (<span class="nv">D</span> : <span class="kt">Type</span>@{w}), D -&gt; IsAlgebraicFlabbyType@{w w} D)
  : ExcludedMiddle_type@{w}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>ptaf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">D</span> : <span class="kt">Type</span>, D -&gt; IsAlgebraicFlabbyType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExcludedMiddle_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkbb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>ptaf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">D</span> : <span class="kt">Type</span>, D -&gt; IsAlgebraicFlabbyType D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ExcludedMiddle_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkbc"><span class="nb">intros</span> P PropP.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>ptaf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">D</span> : <span class="kt">Type</span>, D -&gt; IsAlgebraicFlabbyType D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>PropP</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P + ~ P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkbd"><span class="nb">apply</span> (decidable_alg_flab_hprop (Build_HProp P)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>ptaf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">D</span> : <span class="kt">Type</span>, D -&gt; IsAlgebraicFlabbyType D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>PropP</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAlgebraicFlabbyType
  (Build_HProp P + ~ Build_HProp P + Unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="injectivetypes-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="injectivetypes-v-chkbe"><span class="nb">apply</span> ptaf.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>ptaf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">D</span> : <span class="kt">Type</span>, D -&gt; IsAlgebraicFlabbyType D</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>PropP</var><span class="hyp-type"><b>: </b><span>IsHProp P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_HProp P + ~ Build_HProp P + Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inr tt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
