<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Smallness.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk0"><span class="kn">Require Import</span> Basics.Overture Basics.Equivalences Basics.Trunc Basics.Tactics
  Basics.Nat Types.Unit Types.Sigma Types.<span class="kn">Universe</span> <span class="nf">Types</span>.Equiv HFiber.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Universe Minimization ToSet</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Facts about &quot;small&quot; types  *)</span>

<span class="sd">(** This closely follows Section 2 of the paper &quot;Non-accessible localizations&quot;, by Dan Christensen, https://arxiv.org/abs/2109.06670 *)</span>

<span class="sd">(** Universe variables:  we most often use a subset of [i j k u].  We think of [Type@{i}] as containing the &quot;small&quot; types and [Type@{j}] the &quot;large&quot; types.  In some early results, there are no constraints between [i] and [j], and in others we require that [i &lt;= j], as expected.  While the case [i = j] isn&#39;t particularly interesting, we put some effort into ensuring that it is permitted as well, as there is no semantic reason to exclude it.  The universe variable [k] should be thought of as max(i+1,j), and it is generally required to satisfy [i &lt; k] and [j &lt;= k].  If we assume that [i &lt; j], then we can take [k = j], but we include [k] so that we also allow the case [i = j].  The universe variable [u] is only present because we occasionally use Univalence in [Type@{k}], so the equality types need a larger universe to live in.  Because of this, most results require [k &lt; u].</span>

<span class="sd">Summary of the most common situation:  [i &lt; k &lt; u, j &lt;= k], where [i] is for the small types, [j] is for the large types, [k = max(i+1,j)] and [u] is an ambient universe for Univalence.</span>

<span class="sd">We include universe annotations when they clarify the meaning (e.g. in [IsSmall] and when using [PropResizing]), and also when it is required in order to keep control of the universe variables.</span>

<span class="sd">Note that [IsSmall] is defined in Overture.v. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk1"><span class="kn">Instance</span> <span class="nf">ishprop_issmall</span>@{i j k | i &lt; k, j &lt;= k}
  `{Univalence} (X : <span class="kt">Type</span>@{j})
  : IsHProp (IsSmall@{i j} X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsSmall X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsSmall X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk3"><span class="nb">apply</span> hprop_inhabited_contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmall X -&gt; Contr (IsSmall X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk4"><span class="nb">intros</span> [Z e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Z &lt;~&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (IsSmall X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* [IsSmall X] is equivalent to [IsSmall Z], which is contractible since it is a based path space. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk5">rapply (istrunc_equiv_istrunc { Y : <span class="kt">Type</span>@{i} &amp; Y &lt;~&gt; Z } _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Z &lt;~&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Y : <span class="kt">Type</span> &amp; Y &lt;~&gt; Z} &lt;~&gt; IsSmall X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk6">equiv_via (sig@{k k} (<span class="kr">fun</span> <span class="nv">Y</span> : <span class="kt">Type</span>@{i} =&gt; Y &lt;~&gt; X)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Z &lt;~&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Y : <span class="kt">Type</span> &amp; Y &lt;~&gt; Z} &lt;~&gt; {Y : <span class="kt">Type</span> &amp; Y &lt;~&gt; X}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smallness-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Z &lt;~&gt; X</span></span></span><br></div><label class="goal-separator" for="smallness-v-chk7"><hr></label><div class="goal-conclusion">{Y : <span class="kt">Type</span> &amp; Y &lt;~&gt; X} &lt;~&gt; IsSmall X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk8"><span class="mi">2</span>: issig.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Z &lt;~&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Y : <span class="kt">Type</span> &amp; Y &lt;~&gt; Z} &lt;~&gt; {Y : <span class="kt">Type</span> &amp; Y &lt;~&gt; X}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk9"><span class="nb">apply</span> equiv_functor_sigma_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Z &lt;~&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, (a &lt;~&gt; Z) &lt;~&gt; (a &lt;~&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chka"><span class="nb">intro</span> Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>Z &lt;~&gt; X</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Y &lt;~&gt; Z) &lt;~&gt; (Y &lt;~&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_functor_postcompose_equiv Y e).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A type in [Type@{i}] is clearly small. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">issmall_in</span>@{i j | i &lt;= j} (X : <span class="kt">Type</span>@{i}) : IsSmall@{i j} X | <span class="mi">10</span>
  := Build_IsSmall X X equiv_idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The small types are closed under equivalence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chkb"><span class="kn">Definition</span> <span class="nf">issmall_equiv_issmall</span>@{i1 j1 i2 j2 | i1 &lt;= i2} {A : <span class="kt">Type</span>@{j1}} {B : <span class="kt">Type</span>@{j2}}
  (e : A &lt;~&gt; B) (sA : IsSmall@{i1 j1} A)
  : IsSmall@{i2 j2} B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>sA</var><span class="hyp-type"><b>: </b><span>IsSmall A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmall B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>sA</var><span class="hyp-type"><b>: </b><span>IsSmall A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmall B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chkd"><span class="kr">exists</span> (<span class="nv">smalltype</span> <span class="nv">A</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>sA</var><span class="hyp-type"><b>: </b><span>IsSmall A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">smalltype A &lt;~&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (e oE (equiv_smalltype A)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The small types are closed under dependent sums. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chke"><span class="kn">Definition</span> <span class="nf">sigma_closed_issmall</span>@{i j | } {A : <span class="kt">Type</span>@{j}}
  (B : A -&gt; <span class="kt">Type</span>@{j}) (sA : IsSmall@{i j} A)
  (sB : <span class="kr">forall</span> <span class="nv">a</span>, IsSmall@{i j} (B a))
  : IsSmall@{i j} { a : A &amp; B a }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sA</var><span class="hyp-type"><b>: </b><span>IsSmall A</span></span></span><br><span><var>sB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsSmall (B a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmall {a : A &amp; B a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chkf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sA</var><span class="hyp-type"><b>: </b><span>IsSmall A</span></span></span><br><span><var>sB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsSmall (B a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmall {a : A &amp; B a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk10"><span class="kr">exists</span> { <span class="nv">a</span> : (smalltype A) &amp; (smalltype (B (equiv_smalltype A a))) }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sA</var><span class="hyp-type"><b>: </b><span>IsSmall A</span></span></span><br><span><var>sB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsSmall (B a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{a : smalltype A &amp;
smalltype (B (equiv_smalltype A a))} &lt;~&gt; {a : A &amp; B a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">snapply equiv_functor_sigma&#39;; <span class="nb">intros</span>; <span class="nb">apply</span> equiv_smalltype.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If a map has small codomain and fibers, then the domain is small. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk11"><span class="kn">Definition</span> <span class="nf">issmall_issmall_codomain_fibers</span>@{i j | } {X Y : <span class="kt">Type</span>@{j}}
  (f : X -&gt; Y)
  (sY : IsSmall@{i j} Y)
  (sF : <span class="kr">forall</span> <span class="nv">y</span> : Y, IsSmall@{i j} (hfiber f y))
  : IsSmall@{i j} X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>sY</var><span class="hyp-type"><b>: </b><span>IsSmall Y</span></span></span><br><span><var>sF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, IsSmall (hfiber f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmall X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>sY</var><span class="hyp-type"><b>: </b><span>IsSmall Y</span></span></span><br><span><var>sF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, IsSmall (hfiber f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmall X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk13">napply issmall_equiv_issmall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>sY</var><span class="hyp-type"><b>: </b><span>IsSmall Y</span></span></span><br><span><var>sF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, IsSmall (hfiber f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;~&gt; X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smallness-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>sY</var><span class="hyp-type"><b>: </b><span>IsSmall Y</span></span></span><br><span><var>sF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, IsSmall (hfiber f y)</span></span></span><br></div><label class="goal-separator" for="smallness-v-chk14"><hr></label><div class="goal-conclusion">IsSmall <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk15">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>sY</var><span class="hyp-type"><b>: </b><span>IsSmall Y</span></span></span><br><span><var>sF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, IsSmall (hfiber f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;~&gt; X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_fibration_replacement f)^-<span class="mi">1</span>%equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk16">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>sY</var><span class="hyp-type"><b>: </b><span>IsSmall Y</span></span></span><br><span><var>sF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, IsSmall (hfiber f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmall {y : Y &amp; hfiber f y}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> sigma_closed_issmall; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Every contractible type is small. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issmall_contr</span>@{i j| } (X : <span class="kt">Type</span>@{j}) (T : Contr X)
  : IsSmall@{i j} X
  := issmall_equiv_issmall (equiv_contr_unit)^-<span class="mi">1</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If we can show that [X] is small when it is inhabited, then it is in fact small. This is Remark 2.9 in the paper. It lets us simplify the statement of Proposition 2.8. Note that this implies propositional resizing, so the [PropResizing] assumption is necessary. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk17"><span class="kn">Definition</span> <span class="nf">issmall_inhabited_issmall</span>@{i j k | i &lt; k, j &lt;= k} `{PropResizing} `{Univalence}
  (X : <span class="kt">Type</span>@{j})
  (isX : X -&gt; IsSmall@{i j} X)
  : IsSmall@{i j} X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>isX</var><span class="hyp-type"><b>: </b><span>X -&gt; IsSmall X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmall X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk18"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>isX</var><span class="hyp-type"><b>: </b><span>X -&gt; IsSmall X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmall X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Since [IsSmall] is cumulative in the universe [j], it suffices to prove [IsSmall@{i k} X] for [k] the universe that [IsSmall@{i j}] lives in.  We think of [k] as max(i+1,j). *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk19">rapply (issmall_issmall_codomain_fibers@{i k} isX).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>isX</var><span class="hyp-type"><b>: </b><span>X -&gt; IsSmall X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : IsSmall X, IsSmall (hfiber isX y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk1a"><span class="nb">intro</span> sX.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>isX</var><span class="hyp-type"><b>: </b><span>X -&gt; IsSmall X</span></span></span><br><span><var>sX</var><span class="hyp-type"><b>: </b><span>IsSmall X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmall (hfiber isX sX)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply sigma_closed_issmall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If a type [X] is truncated, then so is [smalltype X]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">istrunc_smalltype</span>@{i j | } (X : <span class="kt">Type</span>@{j}) (n : trunc_index)
  `{IsSmall@{i j} X, IsTrunc n X}
  : IsTrunc n (smalltype X)
  := istrunc_equiv_istrunc X (equiv_smalltype@{i j} X)^-<span class="mi">1</span>%equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Locally small types *)</span>

<span class="sd">(** We say that a type [X] is 0-locally small if it is small, and (n+1)-locally small if its identity types are n-locally small. *)</span>
<span class="c">(* TODO: Can we make this an inductive type and avoid the extra universe variable [k]? *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">IsLocallySmall</span>@{i j k | i &lt; k, j &lt;= k} (n : nat) (X : <span class="kt">Type</span>@{j}) : <span class="kt">Type</span>@{k}
  := <span class="kr">match</span> n <span class="kr">with</span>
    | <span class="mi">0</span>%nat =&gt; IsSmall@{i j} X
    | S m =&gt; <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X, IsLocallySmall m (x = y)
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Existing Class</span> <span class="nf">IsLocallySmall</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Unfold</span> IsLocallySmall : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk1b"><span class="kn">Instance</span> <span class="nf">ishprop_islocallysmall</span>@{i j k | i &lt; k, j &lt;= k} `{Univalence}
  (n : nat) (X : <span class="kt">Type</span>@{j})
  : IsHProp@{k} (IsLocallySmall@{i j k} n X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsLocallySmall n X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsLocallySmall n X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Here and later we use [simple_induction] to control the universe variable. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">revert</span> X; simple_induction n n IHn; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A small type is n-locally small for all [n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk1d"><span class="kn">Instance</span> <span class="nf">islocallysmall_in</span>@{i j k | i &lt;= j, j &lt;= k, i &lt; k}
  (n : nat) (X : <span class="kt">Type</span>@{i})
  : IsLocallySmall@{i j k} n X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk1f"><span class="nb">revert</span> X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, IsLocallySmall n X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk20"><span class="nb">induction</span> n; <span class="nb">intro</span> X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall <span class="mi">0</span> X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smallness-v-chk21" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, IsLocallySmall n X</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="smallness-v-chk21"><hr></label><div class="goal-conclusion">IsLocallySmall n.+<span class="mi">1</span> X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk22">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall <span class="mi">0</span> X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> issmall_in.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk23">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, IsLocallySmall n X</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n.+<span class="mi">1</span> X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk24"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, IsLocallySmall n X</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (IHn (x = y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The n-locally small types are closed under equivalence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk25"><span class="kn">Definition</span> <span class="nf">islocallysmall_equiv_islocallysmall</span>
  @{i j1 j2 k | i &lt; k, j1 &lt;= k, j2 &lt;= k}
  (n : nat) {A : <span class="kt">Type</span>@{j1}} {B : <span class="kt">Type</span>@{j2}}
  (e : A &lt;~&gt; B) (lsA : IsLocallySmall@{i j1 k} n A)
  : IsLocallySmall@{i j2 k} n B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk27"><span class="nb">revert</span> A B e lsA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
A &lt;~&gt; B -&gt; IsLocallySmall n A -&gt; IsLocallySmall n B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk28">simple_induction n n IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
A &lt;~&gt; B -&gt; IsLocallySmall <span class="mi">0</span> A -&gt; IsLocallySmall <span class="mi">0</span> B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smallness-v-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, A &lt;~&gt; B -&gt; IsLocallySmall n A -&gt; IsLocallySmall n B</span></span></span><br></div><label class="goal-separator" for="smallness-v-chk29"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
A &lt;~&gt; B -&gt;
IsLocallySmall n.+<span class="mi">1</span> A -&gt; IsLocallySmall n.+<span class="mi">1</span> B</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
A &lt;~&gt; B -&gt; IsLocallySmall <span class="mi">0</span> A -&gt; IsLocallySmall <span class="mi">0</span> B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> @issmall_equiv_issmall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, A &lt;~&gt; B -&gt; IsLocallySmall n A -&gt; IsLocallySmall n B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>,
A &lt;~&gt; B -&gt;
IsLocallySmall n.+<span class="mi">1</span> A -&gt; IsLocallySmall n.+<span class="mi">1</span> B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk2c"><span class="nb">intros</span> A B e lsA b b&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, A &lt;~&gt; B -&gt; IsLocallySmall n A -&gt; IsLocallySmall n B</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n.+<span class="mi">1</span> A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n (b = b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk2d">napply IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, A &lt;~&gt; B -&gt; IsLocallySmall n A -&gt; IsLocallySmall n B</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n.+<span class="mi">1</span> A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;~&gt; b = b&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smallness-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, A &lt;~&gt; B -&gt; IsLocallySmall n A -&gt; IsLocallySmall n B</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n.+<span class="mi">1</span> A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="smallness-v-chk2e"><hr></label><div class="goal-conclusion">IsLocallySmall n <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk2f">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, A &lt;~&gt; B -&gt; IsLocallySmall n A -&gt; IsLocallySmall n B</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n.+<span class="mi">1</span> A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;~&gt; b = b&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_ap&#39; (e^-<span class="mi">1</span>%equiv) b b&#39;)^-<span class="mi">1</span>%equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk30">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>, A &lt;~&gt; B -&gt; IsLocallySmall n A -&gt; IsLocallySmall n B</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n.+<span class="mi">1</span> A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n (e^-<span class="mi">1</span>%equiv b = e^-<span class="mi">1</span>%equiv b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lsA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A small type is n-locally small for all n. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">islocallysmall_issmall</span>@{i j k | i &lt; k, j &lt;= k} (n : nat)
  (X : <span class="kt">Type</span>@{j}) (sX : IsSmall@{i j} X)
  : IsLocallySmall@{i j k} n X
  := islocallysmall_equiv_islocallysmall n (equiv_smalltype X) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If a type is n-locally small, then it is (n+1)-locally small. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk31"><span class="kn">Instance</span> <span class="nf">islocallysmall_succ</span>@{i j k | i &lt; k, j &lt;= k} (n : nat)
  (X : <span class="kt">Type</span>@{j}) (lsX : IsLocallySmall@{i j k} n X)
  : IsLocallySmall@{i j k} n.+<span class="mi">1</span> X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>lsX</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n.+<span class="mi">1</span> X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk32"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>lsX</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n.+<span class="mi">1</span> X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk33"><span class="nb">revert</span> X lsX; simple_induction n n IHn; <span class="nb">intros</span> X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall <span class="mi">0</span> X -&gt; IsLocallySmall <span class="mi">1</span> X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smallness-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, IsLocallySmall n X -&gt; IsLocallySmall n.+<span class="mi">1</span> X</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="smallness-v-chk34"><hr></label><div class="goal-conclusion">IsLocallySmall n.+<span class="mi">1</span> X -&gt; IsLocallySmall n.+<span class="mi">2</span> X</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk35">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall <span class="mi">0</span> X -&gt; IsLocallySmall <span class="mi">1</span> X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> islocallysmall_issmall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk36">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, IsLocallySmall n X -&gt; IsLocallySmall n.+<span class="mi">1</span> X</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n.+<span class="mi">1</span> X -&gt; IsLocallySmall n.+<span class="mi">2</span> X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk37"><span class="nb">intro</span> lsX.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, IsLocallySmall n X -&gt; IsLocallySmall n.+<span class="mi">1</span> X</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>lsX</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n.+<span class="mi">1</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n.+<span class="mi">2</span> X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk38"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, IsLocallySmall n X -&gt; IsLocallySmall n.+<span class="mi">1</span> X</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>lsX</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n.+<span class="mi">1</span> X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n.+<span class="mi">1</span> (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHn, lsX.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The n-locally small types are closed under dependent sums. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk39"><span class="kn">Instance</span> <span class="nf">sigma_closed_islocallysmall</span>@{i j k | i &lt; k, j &lt;= k}
  (n : nat) {A : <span class="kt">Type</span>@{j}} (B : A -&gt; <span class="kt">Type</span>@{j})
  (lsA : IsLocallySmall@{i j k} n A)
  (lsB : <span class="kr">forall</span> <span class="nv">a</span>, IsLocallySmall@{i j k} n (B a))
  : IsLocallySmall@{i j k} n { a : A &amp; B a }.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n A</span></span></span><br><span><var>lsB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n (B a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n {a : A &amp; B a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n A</span></span></span><br><span><var>lsB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n (B a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n {a : A &amp; B a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk3b"><span class="nb">revert</span> A B lsA lsB.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>),
IsLocallySmall n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n (B a)) -&gt;
IsLocallySmall n {a : A &amp; B a}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk3c">simple_induction n n IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>),
IsLocallySmall <span class="mi">0</span> A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall <span class="mi">0</span> (B a)) -&gt;
IsLocallySmall <span class="mi">0</span> {a : A &amp; B a}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smallness-v-chk3d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>),
IsLocallySmall n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n (B a)) -&gt; IsLocallySmall n {a : A &amp; B a}</span></span></span><br></div><label class="goal-separator" for="smallness-v-chk3d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>),
IsLocallySmall n.+<span class="mi">1</span> A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n.+<span class="mi">1</span> (B a)) -&gt;
IsLocallySmall n.+<span class="mi">1</span> {a : A &amp; B a}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk3e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>),
IsLocallySmall <span class="mi">0</span> A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall <span class="mi">0</span> (B a)) -&gt;
IsLocallySmall <span class="mi">0</span> {a : A &amp; B a}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> @sigma_closed_issmall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk3f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>),
IsLocallySmall n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n (B a)) -&gt; IsLocallySmall n {a : A &amp; B a}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>),
IsLocallySmall n.+<span class="mi">1</span> A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n.+<span class="mi">1</span> (B a)) -&gt;
IsLocallySmall n.+<span class="mi">1</span> {a : A &amp; B a}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk40"><span class="nb">intros</span> A B lsA lsB x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>),
IsLocallySmall n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n (B a)) -&gt; IsLocallySmall n {a : A &amp; B a}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n.+<span class="mi">1</span> A</span></span></span><br><span><var>lsB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n.+<span class="mi">1</span> (B a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>{a : A &amp; B a}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk41"><span class="nb">apply</span> (islocallysmall_equiv_islocallysmall n (equiv_path_sigma _ x y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>),
IsLocallySmall n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n (B a)) -&gt; IsLocallySmall n {a : A &amp; B a}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n.+<span class="mi">1</span> A</span></span></span><br><span><var>lsB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n.+<span class="mi">1</span> (B a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>{a : A &amp; B a}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n
  {p : x.<span class="mi">1</span> = y.<span class="mi">1</span> &amp;
  transport (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; B a) p x.<span class="mi">2</span> = y.<span class="mi">2</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk42"><span class="nb">apply</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>),
IsLocallySmall n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n (B a)) -&gt; IsLocallySmall n {a : A &amp; B a}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n.+<span class="mi">1</span> A</span></span></span><br><span><var>lsB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n.+<span class="mi">1</span> (B a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>{a : A &amp; B a}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n (x.<span class="mi">1</span> = y.<span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smallness-v-chk43" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>),
IsLocallySmall n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n (B a)) -&gt; IsLocallySmall n {a : A &amp; B a}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n.+<span class="mi">1</span> A</span></span></span><br><span><var>lsB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n.+<span class="mi">1</span> (B a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>{a : A &amp; B a}</span></span></span><br></div><label class="goal-separator" for="smallness-v-chk43"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : x.<span class="mi">1</span> = y.<span class="mi">1</span>,
IsLocallySmall n
  (transport (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; B a0) a x.<span class="mi">2</span> = y.<span class="mi">2</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk44">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>),
IsLocallySmall n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n (B a)) -&gt; IsLocallySmall n {a : A &amp; B a}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n.+<span class="mi">1</span> A</span></span></span><br><span><var>lsB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n.+<span class="mi">1</span> (B a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>{a : A &amp; B a}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n (x.<span class="mi">1</span> = y.<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lsA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk45">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>),
IsLocallySmall n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n (B a)) -&gt; IsLocallySmall n {a : A &amp; B a}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n.+<span class="mi">1</span> A</span></span></span><br><span><var>lsB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n.+<span class="mi">1</span> (B a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>{a : A &amp; B a}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : x.<span class="mi">1</span> = y.<span class="mi">1</span>,
IsLocallySmall n
  (transport (<span class="kr">fun</span> <span class="nv">a0</span> : A =&gt; B a0) a x.<span class="mi">2</span> = y.<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk46"><span class="nb">intro</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : A -&gt; <span class="kt">Type</span>),
IsLocallySmall n A -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n (B a)) -&gt; IsLocallySmall n {a : A &amp; B a}</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>lsA</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n.+<span class="mi">1</span> A</span></span></span><br><span><var>lsB</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, IsLocallySmall n.+<span class="mi">1</span> (B a)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>{a : A &amp; B a}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x.<span class="mi">1</span> = y.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n
  (transport (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; B a) p x.<span class="mi">2</span> = y.<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lsB.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If a map has n-locally small codomain and fibers, then the domain is n-locally small. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk47"><span class="kn">Definition</span> <span class="nf">islocallysmall_islocallysmall_codomain_fibers</span>@{i j k | i &lt; k, j &lt;= k}
  (n : nat) {X Y : <span class="kt">Type</span>@{j}} (f : X -&gt; Y)
  (sY : IsLocallySmall@{i j k} n Y)
  (sF : <span class="kr">forall</span> <span class="nv">y</span> : Y, IsLocallySmall@{i j k} n (hfiber f y))
  : IsLocallySmall@{i j k} n X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>sY</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n Y</span></span></span><br><span><var>sF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, IsLocallySmall n (hfiber f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk48"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>sY</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n Y</span></span></span><br><span><var>sF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, IsLocallySmall n (hfiber f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk49">napply islocallysmall_equiv_islocallysmall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>sY</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n Y</span></span></span><br><span><var>sF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, IsLocallySmall n (hfiber f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;~&gt; X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smallness-v-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>sY</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n Y</span></span></span><br><span><var>sF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, IsLocallySmall n (hfiber f y)</span></span></span><br></div><label class="goal-separator" for="smallness-v-chk4a"><hr></label><div class="goal-conclusion">IsLocallySmall n <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk4b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>sY</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n Y</span></span></span><br><span><var>sF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, IsLocallySmall n (hfiber f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal</span> &lt;~&gt; X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_fibration_replacement f)^-<span class="mi">1</span>%equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk4c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>sY</var><span class="hyp-type"><b>: </b><span>IsLocallySmall n Y</span></span></span><br><span><var>sF</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, IsLocallySmall n (hfiber f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall n {y : Y &amp; hfiber f y}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> sigma_closed_islocallysmall; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Under propositional resizing, every (n+1)-truncated type is (n+2)-locally small. This is Lemma 2.3 in the paper. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk4d"><span class="kn">Instance</span> <span class="nf">islocallysmall_trunc</span>@{i j k | i &lt; k, j &lt;= k} `{PropResizing}
  (n : trunc_index) (X : <span class="kt">Type</span>@{j}) (T : IsTrunc n.+<span class="mi">1</span> X)
  : IsLocallySmall@{i j k} (trunc_index_to_nat n) X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall (trunc_index_to_nat n) X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk4e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall (trunc_index_to_nat n) X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk4f"><span class="nb">revert</span> n X T.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">X</span> : <span class="kt">Type</span>),
IsTrunc n.+<span class="mi">1</span> X -&gt;
IsLocallySmall (trunc_index_to_nat n) X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk50">simple_induction n n IHn; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, IsHProp X -&gt; IsSmall X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="smallness-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, IsTrunc n.+<span class="mi">1</span> X -&gt; IsLocallySmall (trunc_index_to_nat n) X</span></span></span><br></div><label class="goal-separator" for="smallness-v-chk51"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
IsTrunc n.+<span class="mi">2</span> X -&gt;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X,
IsLocallySmall (trunc_index_to_nat n) (x = y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk52">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, IsHProp X -&gt; IsSmall X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> issmall_hprop@{i j}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk53">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, IsTrunc n.+<span class="mi">1</span> X -&gt; IsLocallySmall (trunc_index_to_nat n) X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>,
IsTrunc n.+<span class="mi">2</span> X -&gt;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : X,
IsLocallySmall (trunc_index_to_nat n) (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="smallness-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="smallness-v-chk54"><span class="nb">intros</span> X T x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>PropResizing</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">X</span> : <span class="kt">Type</span>, IsTrunc n.+<span class="mi">1</span> X -&gt; IsLocallySmall (trunc_index_to_nat n) X</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">2</span> X</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsLocallySmall (trunc_index_to_nat n) (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
