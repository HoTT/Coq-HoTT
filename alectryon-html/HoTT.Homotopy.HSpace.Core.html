<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Core.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1c8"><span class="kn">Require Export</span> Classes.interfaces.canonical_names (SgOp, sg_op,
    MonUnit, mon_unit, LeftIdentity, left_identity, RightIdentity, right_identity,
    Negate, negate, Associative, simple_associativity, associativity,
    LeftInverse, left_inverse, RightInverse, right_inverse, Commutative, commutativity).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> canonical_names.BinOpNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types Pointed WildCat.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core Truncations.Connectedness.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> trunc_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * H-spaces *)</span>

<span class="sd">(** A (non-coherent) H-space [X] is a pointed type with a binary operation for which the base point is a both a left and a right identity. (See Coherent.v for the notion of a coherent H-space.) We say [X] is left-invertible if left multiplication by any element is an equivalence, and dually for right-invertible. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsHSpace</span> (<span class="nv">X</span> : pType) := {
  hspace_op :: SgOp X;
  hspace_left_identity :: LeftIdentity hspace_op pt;
  hspace_right_identity :: RightIdentity hspace_op pt;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">hspace_mon_unit</span> {<span class="nv">X</span> : pType} `{IsHSpace X} : MonUnit X := pt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_ishspace</span> {<span class="nv">X</span> : pType}
  : { mu : X -&gt; X -&gt; X &amp; prod (<span class="kr">forall</span> <span class="nv">x</span>, mu pt x = x) (<span class="kr">forall</span> <span class="nv">x</span>, mu x pt = x) }
      &lt;~&gt; IsHSpace X := <span class="kp">ltac</span>:(make_equiv).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Left and right multiplication by the base point is always an equivalence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1c9"><span class="kn">Instance</span> <span class="nf">isequiv_hspace_left_op_pt</span> {<span class="nv">X</span> : pType} `{IsHSpace X}
  : IsEquiv (pt *.).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (sg_op pt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1ca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (sg_op pt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1cb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1cb"><span class="nb">apply</span> (isequiv_homotopic idmap); <span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = pt * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (left_identity x)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1cc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1cc"><span class="kn">Instance</span> <span class="nf">isequiv_hspace_right_op_pt</span> {<span class="nv">X</span> : pType} `{IsHSpace X}
  : IsEquiv (.* pt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">y</span> : X =&gt; y * pt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1cd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">y</span> : X =&gt; y * pt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1ce"><span class="nb">apply</span> (isequiv_homotopic idmap); <span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = x * pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (right_identity x)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_hspace_left_op</span> {<span class="nv">X</span> : pType} `{IsHSpace X}
  (x : X) `{IsEquiv _ _ (x *.)} : X &lt;~&gt; X
  := Build_Equiv _ _ (x *.) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_hspace_right_op</span> {<span class="nv">X</span> : pType} `{IsHSpace X}
  (x : X) `{IsEquiv _ _ (.* x)} : X &lt;~&gt; X
  := Build_Equiv _ _ (.* x) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any element of an H-space defines a pointed self-map by left multiplication, in the following sense. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pmap_hspace_left_op</span> {<span class="nv">X</span> : pType} `{IsHSpace X} (x : X)
  : X -&gt;* [X, x] := Build_pMap (x *.) (right_identity x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We make [(x *.)] into a pointed equivalence (when possible). In particular, this makes [(pt *.)] into a pointed self-equivalence. We could have also used the left identity to make [(pt *.)] into a pointed self-equivalence, and then we would get a map that&#39;s equal to the identity as a pointed map; but without coherence (see Coherent.v) this is not necessarily the case for this map. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pequiv_hspace_left_op</span> {<span class="nv">X</span> : pType} `{IsHSpace X}
  (x : X) `{IsEquiv _ _ (x *.)} : X &lt;~&gt;* [X,x]
  := Build_pEquiv&#39; (equiv_hspace_left_op x) (right_identity x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Connected H-spaces *)</span>

<span class="sd">(** For connected H-spaces, left and right multiplication by an element is an equivalence. This is because left and right multiplication by the base point is one, and being an equivalence is a proposition. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1cf" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1cf"><span class="kn">Instance</span> <span class="nf">isequiv_hspace_left_op</span> `{Univalence} {A : pType}
  `{IsHSpace A} `{IsConnected <span class="mi">0</span> A}
  : <span class="kr">forall</span> (<span class="nv">a</span> : A), IsEquiv (a *.).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1d0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1d0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (sg_op a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply conn_point_elim; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1d1"><span class="kn">Instance</span> <span class="nf">isequiv_hspace_right_op</span> `{Univalence} {A : pType}
  `{IsHSpace A} `{IsConnected <span class="mi">0</span> A}
  : <span class="kr">forall</span> (<span class="nv">a</span> : A), IsEquiv (.* a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (<span class="kr">fun</span> <span class="nv">y</span> : A =&gt; y * a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1d2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1d2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>IsConnected (Tr <span class="mi">0</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, IsEquiv (<span class="kr">fun</span> <span class="nv">y</span> : A =&gt; y * a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply conn_point_elim; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Left-invertible H-spaces are homogeneous *)</span>

<span class="sd">(** A homogeneous structure on a pointed type [A] gives, for any point [a : A], a self-equivalence of [A] sending the base point to [a]. (This is the same data as a left-invertible right-unital binary operation.) *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsHomogeneous</span> (<span class="nv">A</span> : pType)
  := ishomogeneous : <span class="kr">forall</span> <span class="nv">a</span>, A &lt;~&gt;* [A, a].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any homogeneous structure can be modified so that the base point is mapped to the pointed identity map. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">homogeneous_pt_id</span> {<span class="nv">A</span> : pType} `{IsHomogeneous A}
  : <span class="kr">forall</span> <span class="nv">a</span>, A &lt;~&gt;* [A,a]
  := <span class="kr">fun</span> <span class="nv">a</span> =&gt; ishomogeneous a o*E (ishomogeneous (point A))^-<span class="mi">1</span>*.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">homogeneous_pt_id_beta</span> {<span class="nv">A</span> : pType} `{IsHomogeneous A}
  : homogeneous_pt_id (point A) ==* pequiv_pmap_idmap
  := peisretr _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">homogeneous_pt_id_beta&#39;</span> `{Funext} {A : pType} `{IsHomogeneous A}
  : homogeneous_pt_id (point A) = pequiv_pmap_idmap
  := <span class="kp">ltac</span>:(<span class="nb">apply</span> path_pequiv, peisretr).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This modified structure makes any homogeneous type into a (left-invertible) H-space. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1d3"><span class="kn">Definition</span> <span class="nf">ishspace_homogeneous</span> {<span class="nv">A</span> : pType} `{IsHomogeneous A}
  : IsHSpace A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSpace A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1d4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1d4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSpace A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1d5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1d5">snapply Build_IsHSpace.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk1d6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><label class="goal-separator" for="core-v-chk1d6"><hr></label><div class="goal-conclusion">LeftIdentity <span class="nl">?hspace_op</span> pt</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk1d7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><label class="goal-separator" for="core-v-chk1d7"><hr></label><div class="goal-conclusion">RightIdentity <span class="nl">?hspace_op</span> pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1d8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1d8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; homogeneous_pt_id a b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1d9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1d9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftIdentity (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : A =&gt; homogeneous_pt_id a b) pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1da" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1da"><span class="nb">intro</span> a; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ishomogeneous pt ((ishomogeneous pt)^-<span class="mi">1</span> a) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1db" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1db">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightIdentity (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : A =&gt; homogeneous_pt_id a b)
  pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1dc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1dc"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHomogeneous A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">homogeneous_pt_id a pt = a</div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (point_eq (homogeneous_pt_id a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Left-invertible H-spaces are homogeneous, giving a logical equivalence between left-invertible H-spaces and homogeneous types. (In fact, the type of homogeneous types with the base point sent to the pointed identity map is equivalent to the type of left-invertible coherent H-spaces, but we don&#39;t prove that here.) See [equiv_iscohhspace_ptd_action] for a closely related result. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Instance</span> <span class="nf">ishomogeneous_hspace</span> {<span class="nv">A</span> : pType} `{IsHSpace A}
  `{<span class="kr">forall</span> <span class="nv">a</span>, IsEquiv (a *.)}
  : IsHomogeneous A
  := (<span class="kr">fun</span> <span class="nv">a</span> =&gt; pequiv_hspace_left_op a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Promoting unpointed homotopies to pointed homotopies *)</span>

<span class="sd">(** Two pointed maps [f g : Y -&gt;* X] into an H-space are equal if and only if they are equal as unpointed maps. (Note: This is a logical &quot;iff&quot;, not an equivalence of types.) This was first observed by Evan Cavallo for homogeneous types. Below we show a generalization due to Egbert Rijke, which we then specialize to H-spaces. Notably, the specialization does not require left-invertibility. This appears as Lemma 2.6 in https://arxiv.org/abs/2301.02636v1 *)</span>

<span class="sd">(** First a version that assumes an equality of the unpointed maps. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1dd"><span class="kn">Definition</span> <span class="nf">phomotopy_from_path_arrow</span> {<span class="nv">A</span> <span class="nv">B</span> : pType}
  (<span class="nv">m</span> : <span class="kr">forall</span> (<span class="nv">a</span> : A), (point A) = (point A) -&gt; a = a)
  (<span class="nv">q</span> : m pt == idmap) {<span class="nv">f</span> <span class="nv">g</span> : B -&gt;* A} (<span class="nv">K</span> : pointed_fun f = pointed_fun g)
  : f ==* g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, pt = pt -&gt; a = a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>m pt == idmap</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1de"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, pt = pt -&gt; a = a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>m pt == idmap</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1df" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1df">napply issig_phomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, pt = pt -&gt; a = a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>m pt == idmap</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : f == g &amp; p pt = dpoint_eq f @ (dpoint_eq g)^}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1e0"><span class="nb">destruct</span> f <span class="kr">as</span> [f fpt], g <span class="kr">as</span> [g gpt]; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, pt = pt -&gt; a = a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>m pt == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>fpt</var><span class="hyp-type"><b>: </b><span>f pt = pt</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>gpt</var><span class="hyp-type"><b>: </b><span>g pt = pt</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : f == g &amp; p pt = fpt @ gpt^}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1e1"><span class="nb">induction</span> K.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, pt = pt -&gt; a = a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>m pt == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>fpt, gpt</var><span class="hyp-type"><b>: </b><span>f pt = pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : f == f &amp; p pt = fpt @ gpt^}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1e2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1e2"><span class="nb">destruct</span> A <span class="kr">as</span> [A a0]; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>IsPointed A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a0 = a0 -&gt; a = a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>m a0 == idmap</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>fpt, gpt</var><span class="hyp-type"><b>: </b><span>f pt = a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : f == f &amp; p pt = fpt @ gpt^}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1e3"><span class="nb">induction</span> fpt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, f pt = f pt -&gt; a = a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>m (f pt) == idmap</span></span></span><br><span><var>gpt</var><span class="hyp-type"><b>: </b><span>f pt = f pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{p : f == f &amp; p pt = <span class="mi">1</span> @ gpt^}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1e4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1e4"><span class="kr">exists</span> (<span class="nv">fun</span> <span class="nv">b</span> =&gt; m (f b) (idpath @ gpt^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B -&gt; A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, f pt = f pt -&gt; a = a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>m (f pt) == idmap</span></span></span><br><span><var>gpt</var><span class="hyp-type"><b>: </b><span>f pt = f pt</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m (f pt) (<span class="mi">1</span> @ gpt^) = <span class="mi">1</span> @ gpt^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Assuming [Funext], we may take [K] to be a homotopy. With a more elaborate proof, [Funext] could be avoided here and therefore in the next result as well. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">phomotopy_from_homotopy</span> `{Funext} {A B : pType}
  (m : <span class="kr">forall</span> (<span class="nv">a</span> : A), (point A) = (point A) -&gt; a = a)
  (q :  m pt == idmap) {f g : B -&gt;* A} (K : f == g)
  : f ==* g
  := phomotopy_from_path_arrow m q (path_forall _ _ K).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We specialize to H-spaces. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1e5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1e5"><span class="kn">Definition</span> <span class="nf">hspace_phomotopy_from_homotopy</span> `{Funext} {A B : pType}
  `{IsHSpace A} {f g : B -&gt;* A} (K : f == g)
  : f ==* g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1e6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1e6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f ==* g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1e7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1e7">snapply (phomotopy_from_homotopy _ _ K).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, pt = pt -&gt; a = a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk1e8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><label class="goal-separator" for="core-v-chk1e8"><hr></label><div class="goal-conclusion"><span class="nl">?m</span> pt == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1e9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1e9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, pt = pt -&gt; a = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1ea" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1ea"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pt = pt -&gt; a = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fmap loops (pmap_hspace_left_op a o* (pequiv_hspace_left_op pt)^-<span class="mi">1</span>*)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1eb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
 pointed_fun
   (fmap loops
      (pmap_hspace_left_op a
       o* (pequiv_hspace_left_op pt)^-<span class="mi">1</span>*))) pt ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1ec" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1ec"><span class="nb">lazy</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops
  (pmap_hspace_left_op pt
   o* (pequiv_hspace_left_op pt)^-<span class="mi">1</span>*) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1ed" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1ed"><span class="nb">transitivity</span> (fmap (b:=A) loops pmap_idmap).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops
  (pmap_hspace_left_op pt
   o* (pequiv_hspace_left_op pt)^-<span class="mi">1</span>*) ==
fmap loops pmap_idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk1ee" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><label class="goal-separator" for="core-v-chk1ee"><hr></label><div class="goal-conclusion">fmap loops pmap_idmap == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1ef" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1ef"><span class="mi">2</span>: tapply (fmap_id loops).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap loops
  (pmap_hspace_left_op pt
   o* (pequiv_hspace_left_op pt)^-<span class="mi">1</span>*) ==
fmap loops pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1f0">tapply (fmap2 loops).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pmap_hspace_left_op pt
o* (pequiv_hspace_left_op pt)^-<span class="mi">1</span>* $== pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">napply peisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A version with actual paths. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1f1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1f1"><span class="kn">Definition</span> <span class="nf">hspace_path_pforall_from_path_arrow</span> `{Funext} {A B : pType}
  `{IsHSpace A} {f g : B -&gt;* A} (K : pointed_fun f = pointed_fun g)
  : f = g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1f2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1f2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1f3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1f3"><span class="nb">apply</span> path_pforall, hspace_phomotopy_from_homotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1f4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1f4"><span class="nb">apply</span> (path_arrow _ _)^-<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>IsHSpace A</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>B -&gt;* A</span></span></span><br><span><var>K</var><span class="hyp-type"><b>: </b><span>f = g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> K.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A type equivalent to an H-space is an H-space. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1f5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1f5"><span class="kn">Definition</span> <span class="nf">ishspace_equiv_hspace</span> {<span class="nv">X</span> <span class="nv">Y</span> : pType} `{IsHSpace Y} (f : X &lt;~&gt;* Y)
  : IsHSpace X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSpace X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1f6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSpace X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1f7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1f7">snapply Build_IsHSpace.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp X</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk1f8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br></div><label class="goal-separator" for="core-v-chk1f8"><hr></label><div class="goal-conclusion">LeftIdentity <span class="nl">?hspace_op</span> pt</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk1f9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br></div><label class="goal-separator" for="core-v-chk1f9"><hr></label><div class="goal-conclusion">RightIdentity <span class="nl">?hspace_op</span> pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1fa" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1fa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; f^-<span class="mi">1</span> (f a * f b)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1fb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1fb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftIdentity (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : X =&gt; f^-<span class="mi">1</span> (f a * f b)) pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1fc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1fc"><span class="nb">intro</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f^-<span class="mi">1</span> (f pt * f b) = b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1fd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1fd">rhs_V <span class="bp">exact</span> (eissect f b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f^-<span class="mi">1</span> (f pt * f b) = f^-<span class="mi">1</span> (f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1fe" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1fe"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f pt * f b = f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk1ff" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk1ff">lhs <span class="bp">exact</span> (ap (.* f b) (point_eq f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pt * f b = f b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> left_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk200" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk200">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightIdentity (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : X =&gt; f^-<span class="mi">1</span> (f a * f b)) pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk201"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f^-<span class="mi">1</span> (f a * f pt) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk202" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk202">rhs_V <span class="bp">exact</span> (eissect f a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f^-<span class="mi">1</span> (f a * f pt) = f^-<span class="mi">1</span> (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk203"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a * f pt = f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk204" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk204">lhs <span class="bp">exact</span> (ap (f a *.) (point_eq f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsHSpace Y</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X &lt;~&gt;* Y</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a * pt = f a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> right_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Every loop space is an H-space. Making this an instance breaks CayleyDickson.v because Coq finds this instance rather than the expected one. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk205" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk205"><span class="kn">Definition</span> <span class="nf">ishspace_loops</span> {<span class="nv">X</span> : pType} : IsHSpace (loops X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSpace (loops X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk206" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk206"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSpace (loops X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk207" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk207">snapply Build_IsHSpace.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp (loops X)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chk208" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk208"><hr></label><div class="goal-conclusion">LeftIdentity <span class="nl">?hspace_op</span> pt</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chk209" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><label class="goal-separator" for="core-v-chk209"><hr></label><div class="goal-conclusion">RightIdentity <span class="nl">?hspace_op</span> pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk20a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk20a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp (loops X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> concat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk20b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk20b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">LeftIdentity concat pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> concat_1p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chk20c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chk20c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span>pType</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightIdentity concat pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> concat_p1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
