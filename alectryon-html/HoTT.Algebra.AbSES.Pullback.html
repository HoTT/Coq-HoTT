<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Pullback.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk0"><span class="kn">From</span> HoTT <span class="kn">Require Import</span> Basics Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HSet Limits.Pullback.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> WildCat Pointed.Core Homotopy.ExactSequence.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modalities.ReflectiveSubuniverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> AbGroups.AbelianGroup AbGroups.AbPullback AbGroups.Biproduct.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> AbSES.Core AbSES.DirectSum.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> abses_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Pullbacks of short exact sequences *)</span>

<span class="sd">(** A short exact sequence [A -&gt; E -&gt; B] can be pulled back along a map [B&#39; -&gt; B]. We start by defining the underlying map, then the pointed version. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk1"><span class="kn">Definition</span> <span class="nf">abses_pullback</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : AbGroup} (<span class="nv">f</span> : B&#39; $-&gt; B)
  : AbSES B A -&gt; AbSES B&#39; A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSES B A -&gt; AbSES B&#39; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSES B A -&gt; AbSES B&#39; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk3"><span class="nb">intro</span> E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSES B&#39; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk4">snapply (Build_AbSES (ab_pullback (projection E) f)
                        (grp_pullback_corec _ _ (inclusion _) grp_homo_const _)
                        (grp_pullback_pr2 (projection _) f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E o inclusion E == f o grp_homo_const</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk5"><hr></label><div class="goal-conclusion">IsEmbedding
  (grp_pullback_corec (projection E) f (inclusion E)
     grp_homo_const <span class="nl">?p</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk6"><hr></label><div class="goal-conclusion">IsConnMap
  (Modality.modality_to_reflective_subuniverse
     (Core.Tr (-<span class="mi">1</span>)))
  (grp_pullback_pr2 (projection E) f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk7"><hr></label><div class="goal-conclusion">IsExact (Core.Tr (-<span class="mi">1</span>))
  (grp_pullback_corec (projection E) f (inclusion E)
     grp_homo_const <span class="nl">?p</span>)
  (grp_pullback_pr2 (projection E) f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E o inclusion E == f o grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk9"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (inclusion E x) = f (grp_homo_const x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chka">nrefine (_ @ (grp_homo_unit f)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (inclusion E x) = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> isexact_inclusion_projection.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding
  (grp_pullback_corec (projection E) f (inclusion E)
     grp_homo_const
     ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
       (<span class="kr">let</span> <span class="nv">X</span> := <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">X0</span> :=
          <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; pointed_fun (X a) <span class="kr">in</span>
        X0 E x) @ (grp_homo_unit f)^)
      :
      projection E o inclusion E == f o grp_homo_const))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (cancelL_isembedding (g:= grp_pullback_pr1 _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap
  (Modality.modality_to_reflective_subuniverse
     (Core.Tr (-<span class="mi">1</span>)))
  (grp_pullback_pr2 (projection E) f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">rapply conn_map_pullback&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsExact (Core.Tr (-<span class="mi">1</span>))
  (grp_pullback_corec (projection E) f (inclusion E)
     grp_homo_const
     ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
       (<span class="kr">let</span> <span class="nv">X</span> := <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">X0</span> :=
          <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; pointed_fun (X a) <span class="kr">in</span>
        X0 E x) @ (grp_homo_unit f)^)
      :
      projection E o inclusion E == f o grp_homo_const))
  (grp_pullback_pr2 (projection E) f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chke">snapply Build_IsExact.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex
  (grp_pullback_corec (projection E) f (inclusion E)
     grp_homo_const
     ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
       (<span class="kr">let</span> <span class="nv">X</span> := <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">X0</span> :=
          <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; pointed_fun (X a) <span class="kr">in</span>
        X0 E x) @ (grp_homo_unit f)^)
      :
      projection E o inclusion E == f o grp_homo_const))
  (grp_pullback_pr2 (projection E) f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkf"><hr></label><div class="goal-conclusion">IsConnMap
  (Modality.modality_to_reflective_subuniverse
     (Core.Tr (-<span class="mi">1</span>))) (cxfib <span class="nl">?cx_isexact</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk10">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex
  (grp_pullback_corec (projection E) f (inclusion E)
     grp_homo_const
     ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
       (<span class="kr">let</span> <span class="nv">X</span> := <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">X0</span> :=
          <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; pointed_fun (X a) <span class="kr">in</span>
        X0 E x) @ (grp_homo_unit f)^)
      :
      projection E o inclusion E == f o grp_homo_const))
  (grp_pullback_pr2 (projection E) f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk11">snapply phomotopy_homotopy_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet B&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk12"><hr></label><div class="goal-conclusion">grp_pullback_pr2 (projection E) f
o* grp_pullback_corec (projection E) f (inclusion E)
     grp_homo_const
     ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
       (<span class="kr">let</span> <span class="nv">X</span> := <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">X0</span> :=
          <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; pointed_fun (X a) <span class="kr">in</span>
        X0 E x) @ (grp_homo_unit f)^)
      :
      projection E o inclusion E == f o grp_homo_const) ==
pconst</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk13">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk14">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pullback_pr2 (projection E) f
o* grp_pullback_corec (projection E) f (inclusion E)
     grp_homo_const
     ((<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
       (<span class="kr">let</span> <span class="nv">X</span> := <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; cx_isexact <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">X0</span> :=
          <span class="kr">fun</span> <span class="nv">a</span> : AbSES&#39; B A =&gt; pointed_fun (X a) <span class="kr">in</span>
        X0 E x) @ (grp_homo_unit f)^)
      :
      projection E o inclusion E == f o grp_homo_const) ==
pconst</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk15">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap
  (Modality.modality_to_reflective_subuniverse
     (Core.Tr (-<span class="mi">1</span>)))
  (cxfib (phomotopy_homotopy_hset (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk16">nrefine (cancelL_equiv_conn_map
                 _ _ (hfiber_pullback_along_pointed f (projection _) (grp_homo_unit _))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap
  (Modality.modality_to_reflective_subuniverse
     (Core.Tr (-<span class="mi">1</span>)))
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
   hfiber_pullback_along_pointed f (projection E)
     (grp_homo_unit f)
     (cxfib
        (phomotopy_homotopy_hset (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)) x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk17">nrefine (conn_map_homotopic _ _ _ _ (conn_map_isexact (IsExact:=isexact_inclusion_projection _))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cxfib cx_isexact ==
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 hfiber_pullback_along_pointed f (projection E)
   (grp_homo_unit f)
   (cxfib (phomotopy_homotopy_hset (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>))
      x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk18"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cxfib cx_isexact a =
hfiber_pullback_along_pointed f (projection E)
  (grp_homo_unit f)
  (cxfib (phomotopy_homotopy_hset (<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>)) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> path_sigma_hprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The universal property of [abses_pullback_morphism] *)</span>

<span class="sd">(** The natural map from the pulled back sequence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk19"><span class="kn">Definition</span> <span class="nf">abses_pullback_morphism</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : AbGroup@{u}}
  (<span class="nv">E</span> : AbSES B A) (<span class="nv">f</span> : B&#39; $-&gt; B)
  : AbSESMorphism (abses_pullback f E) E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism (abses_pullback f E) E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism (abses_pullback f E) E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk1b">snapply (Build_AbSESMorphism grp_homo_id _ f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f E $-&gt; E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk1c"><hr></label><div class="goal-conclusion">inclusion E $o grp_homo_id ==
<span class="nl">?component2</span> $o inclusion (abses_pullback f E)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk1d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk1d"><hr></label><div class="goal-conclusion">projection E $o <span class="nl">?component2</span> ==
f $o projection (abses_pullback f E)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk1e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f E $-&gt; E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_pullback_pr1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk1f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion E $o grp_homo_id ==
grp_pullback_pr1 (projection E) f $o
inclusion (abses_pullback f E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E $o grp_pullback_pr1 (projection E) f ==
f $o projection (abses_pullback f E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> pullback_commsq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any map [f : E -&gt; F] of short exact sequences factors (uniquely) through [abses_pullback F f3]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk21"><span class="kn">Definition</span> <span class="nf">abses_pullback_morphism_corec</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">X</span> <span class="nv">Y</span> : AbGroup@{u}}
  {<span class="nv">E</span> : AbSES B A} {<span class="nv">F</span> : AbSES Y X} (<span class="nv">f</span> : AbSESMorphism E F)
  : AbSESMorphism E (abses_pullback (component3 f) F).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism E (abses_pullback (component3 f) F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism E (abses_pullback (component3 f) F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk23">snapply (Build_AbSESMorphism (component1 f) _ grp_homo_id).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; abses_pullback (component3 f) F</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk24"><hr></label><div class="goal-conclusion">inclusion (abses_pullback (component3 f) F) $o
component1 f == <span class="nl">?component2</span> $o inclusion E</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk25" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk25"><hr></label><div class="goal-conclusion">projection (abses_pullback (component3 f) F) $o
<span class="nl">?component2</span> == grp_homo_id $o projection E</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk26">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $-&gt; abses_pullback (component3 f) F</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk27"><span class="nb">apply</span> (grp_pullback_corec (projection F) (component3 f)
                              (component2 f) (projection E)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : E =&gt; projection F (component2 f x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : E =&gt; component3 f (projection E x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> right_square.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk28">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion (abses_pullback (component3 f) F) $o
component1 f ==
grp_pullback_corec (projection F) (component3 f)
  (component2 f) (projection E) (right_square f) $o
inclusion E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk29"><span class="nb">intro</span> x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(inclusion F (component1 f x); group_unit;
cx_isexact (component1 f x) @
(grp_homo_unit (component3 f))^) =
(component2 f (inclusion E x);
projection E (inclusion E x);
right_square f (inclusion E x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk2a"><span class="nb">apply</span> equiv_path_pullback_hset; <span class="nb">cbn</span>; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion F (component1 f x) =
component2 f (inclusion E x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk2b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk2b"><hr></label><div class="goal-conclusion">group_unit = projection E (inclusion E x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk2c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion F (component1 f x) =
component2 f (inclusion E x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> left_square.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk2d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit = projection E (inclusion E x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> iscomplex_abses.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk2e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pullback (component3 f) F) $o
grp_pullback_corec (projection F) (component3 f)
  (component2 f) (projection E) (right_square f) ==
grp_homo_id $o projection E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The original map factors via the induced map. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk2f"><span class="kn">Definition</span> <span class="nf">abses_pullback_morphism_corec_beta</span> `{Funext}
  {A B X Y : AbGroup@{u}} {E : AbSES B A} {F : AbSES Y X}
  (f : AbSESMorphism E F)
  : f = absesmorphism_compose (abses_pullback_morphism F (component3 f))
                              (abses_pullback_morphism_corec f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f =
absesmorphism_compose
  (abses_pullback_morphism F (component3 f))
  (abses_pullback_morphism_corec f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk30"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f =
absesmorphism_compose
  (abses_pullback_morphism F (component3 f))
  (abses_pullback_morphism_corec f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk31"><span class="nb">apply</span> (equiv_ap issig_AbSESMorphism^-<span class="mi">1</span> _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">issig_AbSESMorphism^-<span class="mi">1</span> f =
issig_AbSESMorphism^-<span class="mi">1</span>
  (absesmorphism_compose
     (abses_pullback_morphism F (component3 f))
     (abses_pullback_morphism_corec f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk32">srapply path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(issig_AbSESMorphism^-<span class="mi">1</span> f).<span class="mi">1</span> =
(issig_AbSESMorphism^-<span class="mi">1</span>
   (absesmorphism_compose
      (abses_pullback_morphism F (component3 f))
      (abses_pullback_morphism_corec f))).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk33"><span class="nb">apply</span> path_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst (issig_AbSESMorphism^-<span class="mi">1</span> f).<span class="mi">1</span> =
fst
  (issig_AbSESMorphism^-<span class="mi">1</span>
     (absesmorphism_compose
        (abses_pullback_morphism F (component3 f))
        (abses_pullback_morphism_corec f))).<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk34"><hr></label><div class="goal-conclusion">snd (issig_AbSESMorphism^-<span class="mi">1</span> f).<span class="mi">1</span> =
snd
  (issig_AbSESMorphism^-<span class="mi">1</span>
     (absesmorphism_compose
        (abses_pullback_morphism F (component3 f))
        (abses_pullback_morphism_corec f))).<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk35"><span class="mi">1</span>: <span class="nb">apply</span> path_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst (fst (issig_AbSESMorphism^-<span class="mi">1</span> f).<span class="mi">1</span>) =
fst
  (fst
     (issig_AbSESMorphism^-<span class="mi">1</span>
        (absesmorphism_compose
           (abses_pullback_morphism F (component3 f))
           (abses_pullback_morphism_corec f))).<span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk36" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk36"><hr></label><div class="goal-conclusion">snd (fst (issig_AbSESMorphism^-<span class="mi">1</span> f).<span class="mi">1</span>) =
snd
  (fst
     (issig_AbSESMorphism^-<span class="mi">1</span>
        (absesmorphism_compose
           (abses_pullback_morphism F (component3 f))
           (abses_pullback_morphism_corec f))).<span class="mi">1</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk37" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, X, Y</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES Y X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk37"><hr></label><div class="goal-conclusion">snd (issig_AbSESMorphism^-<span class="mi">1</span> f).<span class="mi">1</span> =
snd
  (issig_AbSESMorphism^-<span class="mi">1</span>
     (absesmorphism_compose
        (abses_pullback_morphism F (component3 f))
        (abses_pullback_morphism_corec f))).<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">by</span> <span class="nb">apply</span> equiv_path_grouphomomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk38"><span class="kn">Definition</span> <span class="nf">abses_pullback_component1_id&#39;</span>
  {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : AbGroup@{u}} {<span class="nv">E</span> : AbSES B A} {<span class="nv">F</span> : AbSES B&#39; A}
  (<span class="nv">f</span> : AbSESMorphism E F) (<span class="nv">h</span> : component1 f == grp_homo_id)
  : E $== abses_pullback (component3 f) F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component1 f == grp_homo_id</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $== abses_pullback (component3 f) F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk39"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component1 f == grp_homo_id</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $== abses_pullback (component3 f) F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk3a"><span class="nb">pose</span> (g := abses_pullback_morphism_corec f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component1 f == grp_homo_id</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>abses_pullback_morphism_corec f</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism E (abses_pullback (component3 f) F)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">E $== abses_pullback (component3 f) F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk3b">napply abses_path_data_to_iso.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component1 f == grp_homo_id</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>abses_pullback_morphism_corec f</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism E (abses_pullback (component3 f) F)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data E (abses_pullback (component3 f) F)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk3c"><span class="kr">exists</span> (<span class="nv">component2</span> <span class="nv">g</span>); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component1 f == grp_homo_id</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>abses_pullback_morphism_corec f</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism E (abses_pullback (component3 f) F)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">component2 g $o inclusion E ==
inclusion (abses_pullback (component3 f) F)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk3d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component1 f == grp_homo_id</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>abses_pullback_morphism_corec f</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism E (abses_pullback (component3 f) F)</span></span></span></span><br></div><label class="goal-separator" for="pullback-v-chk3d"><hr></label><div class="goal-conclusion">projection E ==
projection (abses_pullback (component3 f) F) $o
component2 g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk3e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component1 f == grp_homo_id</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>abses_pullback_morphism_corec f</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism E (abses_pullback (component3 f) F)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">component2 g $o inclusion E ==
inclusion (abses_pullback (component3 f) F)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">a</span> =&gt; (left_square g a)^ @ ap _ (h a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk3f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>AbSESMorphism E F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>component1 f == grp_homo_id</span></span></span><br><span><var>g</var><span><span class="hyp-body"><b>:= </b><span>abses_pullback_morphism_corec f</span></span><span class="hyp-type"><b>: </b><span>AbSESMorphism E (abses_pullback (component3 f) F)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E ==
projection (abses_pullback (component3 f) F) $o
component2 g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** In particular, if [component1] of a morphism is the identity, then it exhibits the domain as the pullback of the codomain. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pullback_component1_id</span> `{Univalence} {A B B&#39; : AbGroup}
  {E : AbSES B A} {F : AbSES B&#39; A}
  (f : AbSESMorphism E F) (h : component1 f == grp_homo_id)
  : E = abses_pullback (component3 f) F
  := equiv_path_abses_iso (abses_pullback_component1_id&#39; f h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** For any two [E, F : AbSES B A] and [f, g : B&#39; $-&gt; B], there is a morphism [Ef + Fg -&gt; E + F] induced by the universal properties of the pullbacks of E and F, respectively. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_directsum_pullback_morphism</span> `{Funext}
  {A B B&#39; C D D&#39; : AbGroup@{u}} {E : AbSES B A} {F : AbSES D C}
  (f : B&#39; $-&gt; B) (g : D&#39; $-&gt; D)
  : AbSESMorphism
      (abses_direct_sum (abses_pullback f E) (abses_pullback g F))
      (abses_direct_sum E F)
  := functor_abses_directsum
       (abses_pullback_morphism E f) (abses_pullback_morphism F g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** For any two [E, F : AbSES B A] and [f, g : B&#39; $-&gt; B], we have (E + F)(f + g) = Ef + Eg, where + denotes the direct sum. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_directsum_distributive_pullbacks</span> `{Univalence}
  {A B B&#39; C D D&#39; : AbGroup@{u}}
  {E : AbSES B A} {F : AbSES D C} (f : B&#39; $-&gt; B) (g : D&#39; $-&gt; D)
  : abses_pullback (functor_ab_biprod f g) (abses_direct_sum E F)
    = abses_direct_sum (abses_pullback f E) (abses_pullback g F)
  := (abses_pullback_component1_id (abses_directsum_pullback_morphism f g)
        (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath))^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk40"><span class="kn">Definition</span> <span class="nf">abses_path_pullback_projection_commsq</span>
  {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : AbGroup@{u}} (<span class="nv">bt</span> : B&#39; $-&gt; B)
  (<span class="nv">E</span> : AbSES B A) (<span class="nv">F</span> : AbSES B&#39; A) (<span class="nv">p</span> : abses_pullback bt E = F)
  : <span class="kr">exists</span> <span class="nv">phi</span> : middle F $-&gt; E, projection E o phi == bt o projection F.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>bt</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback bt E = F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : F $-&gt; E &amp;
projection E o phi == bt o projection F}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk41"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>bt</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>F</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_pullback bt E = F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : F $-&gt; E &amp;
projection E o phi == bt o projection F}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk42"><span class="nb">induction</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>bt</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{phi : abses_pullback bt E $-&gt; E &amp;
(<span class="kr">fun</span> <span class="nv">x</span> : abses_pullback bt E =&gt; projection E (phi x)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : abses_pullback bt E =&gt;
 bt (projection (abses_pullback bt E) x))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk43"><span class="kr">exists</span> (<span class="nv">grp_pullback_pr1</span> <span class="nv">_</span> <span class="nv">_</span>); <span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>bt</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>abses_pullback bt E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (grp_pullback_pr1 (projection E) bt x) =
bt (projection (abses_pullback bt E) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">napply pullback_commsq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** ** Functoriality of [abses_pullback f] for [f : B&#39; $-&gt; B] *)</span>

<span class="sd">(** As any function, [abses_pullback f] acts on paths. By explicitly describing the analogous action on path data we get an action which computes, this turn out to be useful. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk44"><span class="kn">Instance</span> <span class="nf">is0functor_abses_pullback</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : AbGroup} (<span class="nv">f</span> : B&#39; $-&gt; B)
  : Is0Functor (abses_pullback (A:=A) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (abses_pullback f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk45"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (abses_pullback f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk46">srapply Build_Is0Functor;
    <span class="nb">intros</span> E F p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f E $-&gt; abses_pullback f F</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk47">snrefine (_; (_,_)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (abses_pullback f E)
  (abses_pullback f F)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk48"><hr></label><div class="goal-conclusion"><span class="nl">?proj1</span> $o inclusion (abses_pullback f E) ==
inclusion (abses_pullback f F)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk49" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk49"><hr></label><div class="goal-conclusion">projection (abses_pullback f E) ==
projection (abses_pullback f F) $o <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk4a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (abses_pullback f E)
  (abses_pullback f F)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk4b">srapply equiv_functor_grp_pullback.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism B B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk4c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk4c"><hr></label><div class="goal-conclusion">GroupIsomorphism E F</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk4d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk4d"><hr></label><div class="goal-conclusion">GroupIsomorphism B&#39; B&#39;</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk4e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk4e"><hr></label><div class="goal-conclusion">projection F o <span class="nl">?beta</span> == <span class="nl">?alpha</span> o projection E</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk4f"><hr></label><div class="goal-conclusion"><span class="nl">?alpha</span> o f == f o <span class="nl">?gamma</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk50"><span class="mi">1</span>,<span class="mi">3</span>: <span class="bp">exact</span> grp_iso_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism E F</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk51"><hr></label><div class="goal-conclusion">projection F o <span class="nl">?beta</span> == grp_iso_id o projection E</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk52"><hr></label><div class="goal-conclusion">grp_iso_id o f == f o grp_iso_id</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk53"><span class="mi">1</span>: <span class="bp">exact</span> p.<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F o p.<span class="mi">1</span> == grp_iso_id o projection E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk54" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk54"><hr></label><div class="goal-conclusion">grp_iso_id o f == f o grp_iso_id</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk55"><span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F o p.<span class="mi">1</span> == grp_iso_id o projection E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk56"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection F (p.<span class="mi">1</span> x) = grp_iso_id (projection E x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (snd p.<span class="mi">2</span> x)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk57">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_functor_grp_pullback (projection E)
  (projection F) f f grp_iso_id p.<span class="mi">1</span> grp_iso_id
  ((<span class="kr">fun</span> <span class="nv">x</span> : E =&gt; (snd p.<span class="mi">2</span> x)^)
   :
   projection F o p.<span class="mi">1</span> == grp_iso_id o projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : B&#39; =&gt; <span class="mi">1</span>) $o inclusion (abses_pullback f E) ==
inclusion (abses_pullback f F)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk58"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_functor_grp_pullback (projection E)
   (projection F) f f grp_iso_id p.<span class="mi">1</span> grp_iso_id
   (<span class="kr">fun</span> <span class="nv">x</span> : E =&gt; (snd p.<span class="mi">2</span> x)^) (<span class="kr">fun</span> <span class="nv">x0</span> : B&#39; =&gt; <span class="mi">1</span>) $o
 inclusion (abses_pullback f E)) x =
inclusion (abses_pullback f F) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk59">srapply equiv_path_pullback_hset; <span class="nb">split</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p.<span class="mi">1</span> (inclusion E x) = inclusion F x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk5a"><hr></label><div class="goal-conclusion">group_unit = group_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk5b"><span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p.<span class="mi">1</span> (inclusion E x) = inclusion F x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fst p.<span class="mi">2</span> x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk5c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pullback f E) ==
projection (abses_pullback f F) $o
equiv_functor_grp_pullback (projection E)
  (projection F) f f grp_iso_id p.<span class="mi">1</span> grp_iso_id
  ((<span class="kr">fun</span> <span class="nv">x</span> : E =&gt; (snd p.<span class="mi">2</span> x)^)
   :
   projection F o p.<span class="mi">1</span> == grp_iso_id o projection E)
  (<span class="kr">fun</span> <span class="nv">x0</span> : B&#39; =&gt; <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk5d"><span class="kn">Instance</span> <span class="nf">is1functor_abses_pullback</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : AbGroup} (<span class="nv">f</span> : B&#39; $-&gt; B)
  : Is1Functor (abses_pullback (A:=A) f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (abses_pullback f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk5e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (abses_pullback f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk5f">snapply Build_Is1Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : AbSES B A) (<span class="nv">f0</span> <span class="nv">g</span> : a $-&gt; b),
f0 $== g -&gt;
fmap (abses_pullback f) f0 $==
fmap (abses_pullback f) g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk60"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : AbSES B A,
fmap (abses_pullback f) (Id a) $==
Id (abses_pullback f a)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk61" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk61"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbSES B A) (<span class="nv">f0</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c),
fmap (abses_pullback f) (g $o f0) $==
fmap (abses_pullback f) g $o
fmap (abses_pullback f) f0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk62">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : AbSES B A) (<span class="nv">f0</span> <span class="nv">g</span> : a $-&gt; b),
f0 $== g -&gt;
fmap (abses_pullback f) f0 $==
fmap (abses_pullback f) g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk63"><span class="nb">intros</span> E F p q h x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p $== q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>abses_pullback f E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback f) p).<span class="mi">1</span> x =
(fmap (abses_pullback f) q).<span class="mi">1</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk64">srapply equiv_path_pullback_hset; <span class="nb">split</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p $== q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>abses_pullback f E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p.<span class="mi">1</span> (pullback_pr1 x) = q.<span class="mi">1</span> (pullback_pr1 x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p $== q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>abses_pullback f E</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk65"><hr></label><div class="goal-conclusion">pullback_pr2 x = pullback_pr2 x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk66"><span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p $== q</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>abses_pullback f E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p.<span class="mi">1</span> (pullback_pr1 x) = q.<span class="mi">1</span> (pullback_pr1 x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (h _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk67">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : AbSES B A,
fmap (abses_pullback f) (Id a) $==
Id (abses_pullback f a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk68"><span class="nb">intros</span> E x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>abses_pullback f E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback f) (Id E)).<span class="mi">1</span> x =
(Id (abses_pullback f E)).<span class="mi">1</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> srapply equiv_path_pullback_hset.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk69">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : AbSES B A) (<span class="nv">f0</span> : a $-&gt; b)
(<span class="nv">g</span> : b $-&gt; c),
fmap (abses_pullback f) (g $o f0) $==
fmap (abses_pullback f) g $o
fmap (abses_pullback f) f0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk6a"><span class="nb">intros</span> E F G p q x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F, G</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E $-&gt; F</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>F $-&gt; G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>abses_pullback f E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fmap (abses_pullback f) (q $o p)).<span class="mi">1</span> x =
(fmap (abses_pullback f) q $o
 fmap (abses_pullback f) p).<span class="mi">1</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> srapply equiv_path_pullback_hset.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk6b"><span class="kn">Lemma</span> <span class="nf">ap_abses_pullback</span> `{Univalence} {A B B&#39; : AbGroup} (f : B&#39; $-&gt; B)
  {E F : AbSES B A} (p : E = F)
  : ap (abses_pullback f) p
    = equiv_path_abses_iso (fmap (abses_pullback f) (equiv_path_abses_iso^-<span class="mi">1</span> p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E = F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (abses_pullback f) p =
equiv_path_abses_iso
  (fmap (abses_pullback f) (equiv_path_abses_iso^-<span class="mi">1</span> p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk6c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>E = F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (abses_pullback f) p =
equiv_path_abses_iso
  (fmap (abses_pullback f) (equiv_path_abses_iso^-<span class="mi">1</span> p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk6d"><span class="nb">induction</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (abses_pullback f) <span class="mi">1</span> =
equiv_path_abses_iso
  (fmap (abses_pullback f) (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk6e">nrefine (_ @ ap equiv_path_abses_iso _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (abses_pullback f) <span class="mi">1</span> = equiv_path_abses_iso <span class="nl">?Goal0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk6f"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> =
fmap (abses_pullback f) (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk70"><span class="mi">2</span>: <span class="bp">exact</span> ((fmap_id_strong _ _)^ @ ap _ equiv_path_absesV_1^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (abses_pullback f) <span class="mi">1</span> =
equiv_path_abses_iso (Id (abses_pullback f E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> equiv_path_abses_1^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk71"><span class="kn">Lemma</span> <span class="nf">ap_abses_pullback_data</span> `{Univalence} {A B B&#39; : AbGroup} (f : B&#39; $-&gt; B) {E F : AbSES B A}
  (p : abses_path_data_iso E F)
  : ap (abses_pullback f) (equiv_path_abses_iso p)
    = equiv_path_abses_iso (fmap (abses_pullback f) p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (abses_pullback f) (equiv_path_abses_iso p) =
equiv_path_abses_iso (fmap (abses_pullback f) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk72"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (abses_pullback f) (equiv_path_abses_iso p) =
equiv_path_abses_iso (fmap (abses_pullback f) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk73"><span class="nb">refine</span> (ap_abses_pullback _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso
  (fmap (abses_pullback f)
     (equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso p))) =
equiv_path_abses_iso (fmap (abses_pullback f) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk74"><span class="nb">apply</span> (ap (equiv_path_abses_iso o _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>E, F</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso E F</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso p) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk75"><span class="kn">Definition</span> <span class="nf">abses_pullback_point&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : AbGroup} (<span class="nv">f</span> : B&#39; $-&gt; B)
  : (abses_pullback f pt) $== (point (AbSES B&#39; A)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f pt $== pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk76"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f pt $== pt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk77">snrefine (_; (_, _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (abses_pullback f pt) pt</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk78" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk78"><hr></label><div class="goal-conclusion"><span class="nl">?proj1</span> $o inclusion (abses_pullback f pt) ==
inclusion pt</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk79" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk79"><hr></label><div class="goal-conclusion">projection (abses_pullback f pt) ==
projection pt $o <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk7a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (abses_pullback f pt) pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk7b">snapply Build_GroupIsomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (abses_pullback f pt) pt</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk7c"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?grp_iso_homo</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk7d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (abses_pullback f pt) pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk7e">srapply ab_biprod_corec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f pt $-&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk7f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk7f"><hr></label><div class="goal-conclusion">abses_pullback f pt $-&gt; B&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk80">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f pt $-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk81"><span class="nb">refine</span> (ab_biprod_pr1 $o _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f pt $-&gt; ab_biprod A <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_pullback_pr1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk82">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f pt $-&gt; B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> projection.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk83">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (ab_biprod_corec
     (ab_biprod_pr1 $o
      grp_pullback_pr1 (projection pt) f)
     (projection (abses_pullback f pt)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk84">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pt -&gt; abses_pullback f pt</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk85" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk85"><hr></label><div class="goal-conclusion">ab_biprod_corec
  (ab_biprod_pr1 $o grp_pullback_pr1 (projection pt) f)
  (projection (abses_pullback f pt)) o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk86" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk86"><hr></label><div class="goal-conclusion"><span class="nl">?g</span>
o ab_biprod_corec
    (ab_biprod_pr1 $o
     grp_pullback_pr1 (projection pt) f)
    (projection (abses_pullback f pt)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk87">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pt -&gt; abses_pullback f pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk88">snapply grp_pullback_corec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pt $-&gt; pt</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk89" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk89"><hr></label><div class="goal-conclusion">pt $-&gt; B&#39;</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk8a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk8a"><hr></label><div class="goal-conclusion">projection pt o <span class="nl">?b</span> == f o <span class="nl">?c</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk8b">--</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pt $-&gt; pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (functor_ab_biprod grp_homo_id f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk8c">--</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pt $-&gt; B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ab_biprod_pr2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk8d">--</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection pt o functor_ab_biprod grp_homo_id f ==
f o ab_biprod_pr2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk8e">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_biprod_corec
  (ab_biprod_pr1 $o grp_pullback_pr1 (projection pt) f)
  (projection (abses_pullback f pt))
o grp_pullback_corec (projection pt) f
    (functor_ab_biprod grp_homo_id f) ab_biprod_pr2
    (<span class="kr">fun</span> <span class="nv">x0</span> : A * B&#39; =&gt; <span class="mi">1</span>) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk8f">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pullback_corec (projection pt) f
  (functor_ab_biprod grp_homo_id f) ab_biprod_pr2
  (<span class="kr">fun</span> <span class="nv">x0</span> : A * B&#39; =&gt; <span class="mi">1</span>)
o ab_biprod_corec
    (ab_biprod_pr1 $o
     grp_pullback_pr1 (projection pt) f)
    (projection (abses_pullback f pt)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk90"><span class="nb">intros</span> [[a b] [b&#39; c]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>projection pt (a, b) = f b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pullback_corec (projection pt) f
  (functor_ab_biprod grp_homo_id f) ab_biprod_pr2
  (<span class="kr">fun</span> <span class="nv">x0</span> : A * B&#39; =&gt; <span class="mi">1</span>)
  (ab_biprod_corec
     (ab_biprod_pr1 $o
      grp_pullback_pr1 (projection pt) f)
     (projection (abses_pullback f pt))
     ((a, b); b&#39;; c)) = ((a, b); b&#39;; c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk91">srapply equiv_path_pullback_hset; <span class="nb">split</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>projection pt (a, b) = f b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a, f b&#39;) = (a, b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk92" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>projection pt (a, b) = f b&#39;</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk92"><hr></label><div class="goal-conclusion">b&#39; = b&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk93"><span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B&#39;</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>projection pt (a, b) = f b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a, f b&#39;) = (a, b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_prod&#39; idpath c^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk94">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  grp_iso_homo :=
    ab_biprod_corec
      (ab_biprod_pr1 $o
       grp_pullback_pr1 (projection pt) f)
      (projection (abses_pullback f pt));
  isequiv_group_iso :=
    isequiv_adjointify
      (ab_biprod_corec
         (ab_biprod_pr1 $o
          grp_pullback_pr1 (projection pt) f)
         (projection (abses_pullback f pt)))
      (grp_pullback_corec (projection pt) f
         (functor_ab_biprod grp_homo_id f)
         ab_biprod_pr2 (<span class="kr">fun</span> <span class="nv">x0</span> : A * B&#39; =&gt; <span class="mi">1</span>))
      (<span class="kr">fun</span> <span class="nv">x0</span> : A * B&#39; =&gt; <span class="mi">1</span>)
      ((<span class="kr">fun</span> <span class="nv">x</span> : abses_pullback f pt =&gt;
        (<span class="kr">fun</span> <span class="nv">proj1</span> : pt =&gt;
         (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B)
            (<span class="nv">proj2</span> : {c : B&#39; &amp;
                     projection pt (a, b) = f c}) =&gt;
          (<span class="kr">fun</span> (<span class="nv">b&#39;</span> : B&#39;)
             (<span class="nv">c</span> : projection pt (a, b) = f b&#39;) =&gt;
           equiv_path_pullback_hset (projection pt) f
             (grp_pullback_corec (projection pt) f
                (functor_ab_biprod grp_homo_id f)
                ab_biprod_pr2 (<span class="kr">fun</span> <span class="nv">x0</span> : A * B&#39; =&gt; <span class="mi">1</span>)
                (ab_biprod_corec
                   (ab_biprod_pr1 $o
                    grp_pullback_pr1 ... f)
                   (projection (...)) ((a, b); b&#39;; c)))
             ((a, b); b&#39;; c)
             (path_prod&#39; <span class="mi">1</span> c^
              :
              (grp_pullback_corec (projection pt) f
                 (functor_ab_biprod grp_homo_id f)
                 ab_biprod_pr2 (... =&gt; <span class="mi">1</span>)
                 (ab_biprod_corec ... ... ...)).<span class="mi">1</span> =
              ((a, b); b&#39;; c).<span class="mi">1</span>,
             <span class="mi">1</span>
             :
             ((grp_pullback_corec (...) f (...)
                 ab_biprod_pr2 (...) (...)).<span class="mi">2</span>).<span class="mi">1</span> =
             (((a, b); b&#39;; c).<span class="mi">2</span>).<span class="mi">1</span>)) proj2.<span class="mi">1</span> proj2.<span class="mi">2</span>)
           (fst proj1) (snd proj1)) x.<span class="mi">1</span> x.<span class="mi">2</span>)
       :
       grp_pullback_corec (projection pt) f
         (functor_ab_biprod grp_homo_id f)
         ab_biprod_pr2 (<span class="kr">fun</span> <span class="nv">x0</span> : A * B&#39; =&gt; <span class="mi">1</span>)
       o ab_biprod_corec
           (ab_biprod_pr1 $o
            grp_pullback_pr1 (projection pt) f)
           (projection (abses_pullback f pt)) == idmap)
|} $o inclusion (abses_pullback f pt) == inclusion pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk95">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pullback f pt) ==
projection pt $o
{|
  grp_iso_homo :=
    ab_biprod_corec
      (ab_biprod_pr1 $o
       grp_pullback_pr1 (projection pt) f)
      (projection (abses_pullback f pt));
  isequiv_group_iso :=
    isequiv_adjointify
      (ab_biprod_corec
         (ab_biprod_pr1 $o
          grp_pullback_pr1 (projection pt) f)
         (projection (abses_pullback f pt)))
      (grp_pullback_corec (projection pt) f
         (functor_ab_biprod grp_homo_id f)
         ab_biprod_pr2 (<span class="kr">fun</span> <span class="nv">x0</span> : A * B&#39; =&gt; <span class="mi">1</span>))
      (<span class="kr">fun</span> <span class="nv">x0</span> : A * B&#39; =&gt; <span class="mi">1</span>)
      ((<span class="kr">fun</span> <span class="nv">x</span> : abses_pullback f pt =&gt;
        (<span class="kr">fun</span> <span class="nv">proj1</span> : pt =&gt;
         (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B)
            (<span class="nv">proj2</span> : {c : B&#39; &amp;
                     projection pt (a, b) = f c}) =&gt;
          (<span class="kr">fun</span> (<span class="nv">b&#39;</span> : B&#39;)
             (<span class="nv">c</span> : projection pt (a, b) = f b&#39;) =&gt;
           equiv_path_pullback_hset (projection pt) f
             (grp_pullback_corec (projection pt) f
                (functor_ab_biprod grp_homo_id f)
                ab_biprod_pr2 (<span class="kr">fun</span> <span class="nv">x0</span> : A * B&#39; =&gt; <span class="mi">1</span>)
                (ab_biprod_corec
                   (ab_biprod_pr1 $o
                    grp_pullback_pr1 ... f)
                   (projection (...)) ((a, b); b&#39;; c)))
             ((a, b); b&#39;; c)
             (path_prod&#39; <span class="mi">1</span> c^
              :
              (grp_pullback_corec (projection pt) f
                 (functor_ab_biprod grp_homo_id f)
                 ab_biprod_pr2 (... =&gt; <span class="mi">1</span>)
                 (ab_biprod_corec ... ... ...)).<span class="mi">1</span> =
              ((a, b); b&#39;; c).<span class="mi">1</span>,
             <span class="mi">1</span>
             :
             ((grp_pullback_corec (...) f (...)
                 ab_biprod_pr2 (...) (...)).<span class="mi">2</span>).<span class="mi">1</span> =
             (((a, b); b&#39;; c).<span class="mi">2</span>).<span class="mi">1</span>)) proj2.<span class="mi">1</span> proj2.<span class="mi">2</span>)
           (fst proj1) (snd proj1)) x.<span class="mi">1</span> x.<span class="mi">2</span>)
       :
       grp_pullback_corec (projection pt) f
         (functor_ab_biprod grp_homo_id f)
         ab_biprod_pr2 (<span class="kr">fun</span> <span class="nv">x0</span> : A * B&#39; =&gt; <span class="mi">1</span>)
       o ab_biprod_corec
           (ab_biprod_pr1 $o
            grp_pullback_pr1 (projection pt) f)
           (projection (abses_pullback f pt)) == idmap)
|}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pullback_point</span> `{Univalence} {A B B&#39; : AbGroup} (f : B&#39; $-&gt; B)
  : abses_pullback f pt = pt :&gt; AbSES B&#39; A
  := equiv_path_abses_iso (abses_pullback_point&#39; f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pullback&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : AbGroup} (<span class="nv">f</span> : B&#39; $-&gt; B)
  : AbSES B A --&gt;* AbSES B&#39; A
  := Build_BasepointPreservingFunctor (abses_pullback f) (abses_pullback_point&#39; f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Pullback of short exact sequences as a pointed map. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pullback_pmap</span> `{Univalence} {A B B&#39; : AbGroup} (f : B&#39; $-&gt; B)
  : AbSES B A -&gt;* AbSES B&#39; A
  := to_pointed (abses_pullback&#39; f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Functoriality of [abses_pullback] *)</span>

<span class="sd">(** [abses_pullback] is pseudo-functorial, and we can state this in terms of actual homotopies or &quot;path data homotopies.&quot; We decorate the latter with the suffix (&#39;). *)</span>

<span class="sd">(** For every [E : AbSES B A], the pullback of [E] along [id_B] is [E]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk96"><span class="kn">Definition</span> <span class="nf">abses_pullback_id</span> `{Univalence} {A B : AbGroup}
  : abses_pullback (A:=A) (@grp_homo_id B) == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback grp_homo_id == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk97"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback grp_homo_id == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk98"><span class="nb">intro</span> E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback grp_homo_id E = E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk99"><span class="nb">apply</span> equiv_path_abses_iso; srefine (_; (_, _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (abses_pullback grp_homo_id E) E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk9a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk9a"><hr></label><div class="goal-conclusion"><span class="nl">?proj1</span> $o inclusion (abses_pullback grp_homo_id E) ==
inclusion E</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk9b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk9b"><hr></label><div class="goal-conclusion">projection (abses_pullback grp_homo_id E) ==
projection E $o <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk9c"><span class="mi">1</span>: rapply (Build_GroupIsomorphism _ _ (grp_pullback_pr1 _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  grp_iso_homo :=
    grp_pullback_pr1 (projection E) grp_homo_id;
  isequiv_group_iso :=
    isequiv_pr1
      (<span class="kr">fun</span> <span class="nv">b</span> : E =&gt;
       {c : B &amp; projection E b = grp_homo_id c})
|} $o inclusion (abses_pullback grp_homo_id E) ==
inclusion E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk9d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk9d"><hr></label><div class="goal-conclusion">projection (abses_pullback grp_homo_id E) ==
projection E $o
{|
  grp_iso_homo :=
    grp_pullback_pr1 (projection E) grp_homo_id;
  isequiv_group_iso :=
    isequiv_pr1
      (<span class="kr">fun</span> <span class="nv">b</span> : E =&gt;
       {c : B &amp; projection E b = grp_homo_id c})
|}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk9e"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pullback grp_homo_id E) ==
projection E $o
{|
  grp_iso_homo :=
    grp_pullback_pr1 (projection E) grp_homo_id;
  isequiv_group_iso :=
    isequiv_pr1
      (<span class="kr">fun</span> <span class="nv">b</span> : E =&gt;
       {c : B &amp; projection E b = grp_homo_id c})
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk9f"><span class="nb">intros</span> [a [p q]]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>projection E a = grp_homo_id p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = projection E a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> q^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chka0"><span class="kn">Definition</span> <span class="nf">abses_pullback_pmap_id</span> `{Univalence} {A B : AbGroup}
  : abses_pullback_pmap (A:=A) (@grp_homo_id B) ==* pmap_idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_pmap grp_homo_id ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chka1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_pmap grp_homo_id ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chka2">srapply Build_pHomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_pmap grp_homo_id == pmap_idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chka3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="pullback-v-chka3"><hr></label><div class="goal-conclusion"><span class="nl">?p</span> pt =
dpoint_eq (abses_pullback_pmap grp_homo_id) @
(dpoint_eq pmap_idmap)^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chka4"><span class="mi">1</span>: <span class="bp">exact</span> abses_pullback_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_id pt =
dpoint_eq (abses_pullback_pmap grp_homo_id) @
(dpoint_eq pmap_idmap)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chka5"><span class="nb">refine</span> (_ @ (concat_p1 _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_id pt =
dpoint_eq (abses_pullback_pmap grp_homo_id)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chka6">napply (ap equiv_path_abses_iso).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({|
   grp_iso_homo :=
     grp_pullback_pr1 (projection pt) grp_homo_id;
   isequiv_group_iso :=
     isequiv_pr1
       (<span class="kr">fun</span> <span class="nv">b</span> : pt =&gt;
        {c : B &amp; projection pt b = grp_homo_id c})
 |};
(<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>,
<span class="kr">fun</span> <span class="nv">x</span> : abses_pullback grp_homo_id pt =&gt; ((x.<span class="mi">2</span>).<span class="mi">2</span>)^)) =
bp_pointed (abses_pullback&#39; grp_homo_id)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chka7"><span class="nb">apply</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({|
   grp_iso_homo :=
     grp_pullback_pr1 (projection pt) grp_homo_id;
   isequiv_group_iso :=
     isequiv_pr1
       (<span class="kr">fun</span> <span class="nv">b</span> : pt =&gt;
        {c : B &amp; projection pt b = grp_homo_id c})
 |};
(<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>,
<span class="kr">fun</span> <span class="nv">x</span> : abses_pullback grp_homo_id pt =&gt; ((x.<span class="mi">2</span>).<span class="mi">2</span>)^)).<span class="mi">1</span> =
(bp_pointed (abses_pullback&#39; grp_homo_id)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chka8"><span class="nb">apply</span> equiv_path_groupisomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({|
   grp_iso_homo :=
     grp_pullback_pr1 (projection pt) grp_homo_id;
   isequiv_group_iso :=
     isequiv_pr1
       (<span class="kr">fun</span> <span class="nv">b</span> : pt =&gt;
        {c : B &amp; projection pt b = grp_homo_id c})
 |};
(<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; <span class="mi">1</span>,
<span class="kr">fun</span> <span class="nv">x</span> : abses_pullback grp_homo_id pt =&gt; ((x.<span class="mi">2</span>).<span class="mi">2</span>)^)).<span class="mi">1</span> ==
(bp_pointed (abses_pullback&#39; grp_homo_id)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chka9"><span class="nb">intros</span> [[a b] [b&#39; p]]; <span class="nb">cbn</span>; <span class="nb">cbn</span> <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b, b'</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>b = b&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a, b) = (a, b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> path_prod&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkaa"><span class="kn">Definition</span> <span class="nf">abses_pullback_compose&#39;</span> {<span class="nv">A</span> <span class="nv">B0</span> <span class="nv">B1</span> <span class="nv">B2</span> : AbGroup@{u}}
  (<span class="nv">f</span> : B0 $-&gt; B1) (<span class="nv">g</span> : B1 $-&gt; B2)
  : abses_pullback (A:=A) f o abses_pullback g $=&gt; abses_pullback (g $o f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f o abses_pullback g $=&gt;
abses_pullback (g $o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkab"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f o abses_pullback g $=&gt;
abses_pullback (g $o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkac"><span class="nb">intro</span> E; srefine (_; (_,_)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B2 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism
  (abses_pullback f (abses_pullback g E))
  (abses_pullback (g $o f) E)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chkad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B2 A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkad"><hr></label><div class="goal-conclusion"><span class="nl">?proj1</span> $o
inclusion (abses_pullback f (abses_pullback g E)) ==
inclusion (abses_pullback (g $o f) E)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B2 A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkae"><hr></label><div class="goal-conclusion">projection (abses_pullback f (abses_pullback g E)) ==
projection (abses_pullback (g $o f) E) $o <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkaf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B2 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism
  (abses_pullback f (abses_pullback g E))
  (abses_pullback (g $o f) E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_grp_pullback_compose_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkb0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B2 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_grp_pullback_compose_r (projection E) f g $o
inclusion (abses_pullback f (abses_pullback g E)) ==
inclusion (abses_pullback (g $o f) E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkb1"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B2 A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(equiv_grp_pullback_compose_r (projection E) f g $o
 inclusion (abses_pullback f (abses_pullback g E))) a =
inclusion (abses_pullback (g $o f) E) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> srapply equiv_path_pullback_hset.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkb2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B2 A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pullback f (abses_pullback g E)) ==
projection (abses_pullback (g $o f) E) $o
equiv_grp_pullback_compose_r (projection E) f g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The analog of [abses_pullback_compose&#39;] with actual homotopies. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pullback_compose</span> `{Univalence}
  {A B0 B1 B2 : AbGroup@{u}} (f : B0 $-&gt; B1) (g : B1 $-&gt; B2)
  : abses_pullback (A:=A) f o abses_pullback g == abses_pullback (g $o f)
  := <span class="kr">fun</span> <span class="nv">x</span> =&gt; equiv_path_abses_iso (abses_pullback_compose&#39; f g x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We now work towards *pointed* composition of pullback ([abses_pullback_pcompose]). The proof of pointedness will matter when we later prove that pulling back along a short exact sequence is exact (i.e. that the complex [iscomplex_pullback_abses] below is exact). For this reason we carefully construct the proof of pointedness in terms of the analog [abses_pullback_pcompose&#39;] on path data, which computes. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkb3"><span class="kn">Definition</span> <span class="nf">abses_pullback_pcompose&#39;</span> {<span class="nv">B0</span> <span class="nv">B1</span> <span class="nv">B2</span> <span class="nv">A</span> : AbGroup}
  (<span class="nv">f</span> : B0 $-&gt; B1) (<span class="nv">g</span> : B1 $-&gt; B2)
  : abses_pullback&#39; f $o* abses_pullback&#39; g $=&gt;* abses_pullback&#39; (A:=A) (g $o f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B0, B1, B2, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback&#39; f $o* abses_pullback&#39; g $=&gt;*
abses_pullback&#39; (g $o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkb4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B0, B1, B2, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback&#39; f $o* abses_pullback&#39; g $=&gt;*
abses_pullback&#39; (g $o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkb5"><span class="kr">exists</span> (<span class="nv">abses_pullback_compose&#39;</span> <span class="nv">f</span> <span class="nv">g</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B0, B1, B2, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_compose&#39; f g pt $==
bp_pointed (abses_pullback&#39; f $o* abses_pullback&#39; g) $@
(bp_pointed (abses_pullback&#39; (g $o f)))^$</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkb6"><span class="nb">intros</span> [[[a b2] [b1 c]] [b0 c&#39;]]; <span class="nb">cbn</span> <span class="kr">in</span> c, c&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B0, B1, B2, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b2</var><span class="hyp-type"><b>: </b><span>B2</span></span></span><br><span><var>b1</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>b2 = g b1</span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B0</span></span></span><br><span><var>c'</var><span class="hyp-type"><b>: </b><span>b1 = f b0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(abses_pullback_compose&#39; f g pt).<span class="mi">1</span>
  (((a, b2); b1; c); b0; c&#39;) =
(bp_pointed (abses_pullback&#39; f $o* abses_pullback&#39; g) $@
 (bp_pointed (abses_pullback&#39; (g $o f)))^$).<span class="mi">1</span>
  (((a, b2); b1; c); b0; c&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkb7">srapply equiv_path_pullback_hset; <span class="nb">split</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B0, B1, B2, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b2</var><span class="hyp-type"><b>: </b><span>B2</span></span></span><br><span><var>b1</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>b2 = g b1</span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B0</span></span></span><br><span><var>c'</var><span class="hyp-type"><b>: </b><span>b1 = f b0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a, b2) = (a, g (f b0))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chkb8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B0, B1, B2, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b2</var><span class="hyp-type"><b>: </b><span>B2</span></span></span><br><span><var>b1</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>b2 = g b1</span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B0</span></span></span><br><span><var>c'</var><span class="hyp-type"><b>: </b><span>b1 = f b0</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkb8"><hr></label><div class="goal-conclusion">b0 = b0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkb9"><span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B0, B1, B2, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b2</var><span class="hyp-type"><b>: </b><span>B2</span></span></span><br><span><var>b1</var><span class="hyp-type"><b>: </b><span>B1</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>b2 = g b1</span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>B0</span></span></span><br><span><var>c'</var><span class="hyp-type"><b>: </b><span>b1 = f b0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a, b2) = (a, g (f b0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_prod&#39; idpath (c @ ap g c&#39;)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkba"><span class="kn">Definition</span> <span class="nf">abses_pullback_pcompose</span> `{Univalence} {A B0 B1 B2 : AbGroup}
  (f : B0 $-&gt; B1) (g : B1 $-&gt; B2)
  : abses_pullback_pmap (A:=A) f o* abses_pullback_pmap g ==* abses_pullback_pmap (g $o f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_pmap f o* abses_pullback_pmap g ==*
abses_pullback_pmap (g $o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkbb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_pmap f o* abses_pullback_pmap g ==*
abses_pullback_pmap (g $o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkbc"><span class="nb">refine</span> (to_pointed_compose _ _ @* _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_pointed (abses_pullback&#39; f $o* abses_pullback&#39; g) ==*
abses_pullback_pmap (g $o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkbd"><span class="nb">apply</span> equiv_ptransformation_phomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback&#39; f $o* abses_pullback&#39; g $=&gt;*
abses_pullback&#39; (g $o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> abses_pullback_pcompose&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Pulling back along constant maps *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkbe"><span class="kn">Lemma</span> <span class="nf">abses_pullback_const&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : AbGroup}
  : const pt $=&gt; (@abses_pullback A B B&#39; grp_homo_const).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">const pt $=&gt; abses_pullback grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkbf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">const pt $=&gt; abses_pullback grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkc0"><span class="nb">intro</span> E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">const pt E $-&gt; abses_pullback grp_homo_const E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkc1"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_iso (const pt E)
  (abses_pullback grp_homo_const E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkc2">napply abses_path_data_to_iso.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data (const pt E)
  (abses_pullback grp_homo_const E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkc3">srefine (_;(_,_)); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (grp_prod A B&#39;)
  (grp_pullback (projection E)
     (grp_homo_compose (grp_trivial_rec B)
        (grp_trivial_corec B&#39;)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chkc4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkc4"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="nl">?Goal</span> (x, group_unit)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 (inclusion E x; group_unit;
 cx_isexact x @
 (grp_homo_unit
    (grp_homo_compose (grp_trivial_rec B)
       (grp_trivial_corec B&#39;)))^))</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chkc5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkc5"><hr></label><div class="goal-conclusion">snd == (<span class="kr">fun</span> <span class="nv">x</span> : A * B&#39; =&gt; pullback_pr2 (<span class="nl">?Goal</span> x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkc6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (grp_prod A B&#39;)
  (grp_pullback (projection E)
     (grp_homo_compose (grp_trivial_rec B)
        (grp_trivial_corec B&#39;)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkc7">srapply grp_pullback_corec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod A B&#39; $-&gt; E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chkc8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkc8"><hr></label><div class="goal-conclusion">grp_prod A B&#39; $-&gt; B&#39;</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chkc9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkc9"><hr></label><div class="goal-conclusion">projection E o <span class="nl">?b</span> ==
grp_homo_compose (grp_trivial_rec B)
  (grp_trivial_corec B&#39;) o <span class="nl">?c</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkca">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod A B&#39; $-&gt; E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (inclusion _ $o ab_biprod_pr1).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkcb">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod A B&#39; $-&gt; B&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ab_biprod_pr2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkcc">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E o (inclusion E $o ab_biprod_pr1) ==
grp_homo_compose (grp_trivial_rec B)
  (grp_trivial_corec B&#39;) o ab_biprod_pr2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkcd"><span class="nb">intro</span> x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>grp_prod A B&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (inclusion E (fst x)) = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> iscomplex_abses.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkce">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 grp_pullback_corec (projection E)
   (grp_homo_compose (grp_trivial_rec B)
      (grp_trivial_corec B&#39;))
   (inclusion E $o ab_biprod_pr1) ab_biprod_pr2
   ((<span class="kr">fun</span> <span class="nv">x0</span> : grp_prod A B&#39; =&gt;
     (<span class="kr">let</span> <span class="nv">X</span> :=
        <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; B A =&gt;
        pointed_fun (iscomplex_abses E) <span class="kr">in</span>
      X E (fst x0))
     :
     projection E ((inclusion E $o ab_biprod_pr1) x0) =
     grp_homo_compose (grp_trivial_rec B)
       (grp_trivial_corec B&#39;) (ab_biprod_pr2 x0))
    :
    projection E o (inclusion E $o ab_biprod_pr1) ==
    grp_homo_compose (grp_trivial_rec B)
      (grp_trivial_corec B&#39;) o ab_biprod_pr2)
   (x, group_unit)) ==
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
 (inclusion E x; group_unit;
 cx_isexact x @
 (grp_homo_unit
    (grp_homo_compose (grp_trivial_rec B)
       (grp_trivial_corec B&#39;)))^))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkcf"><span class="nb">intro</span> a; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(inclusion E a; group_unit; iscomplex_abses E a) =
(inclusion E a; group_unit;
cx_isexact a @
(grp_homo_unit
   (grp_homo_compose (grp_trivial_rec B)
      (grp_trivial_corec B&#39;)))^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> srapply equiv_path_pullback_hset; <span class="nb">split</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkd0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd ==
(<span class="kr">fun</span> <span class="nv">x</span> : A * B&#39; =&gt;
 pullback_pr2
   (grp_pullback_corec (projection E)
      (grp_homo_compose (grp_trivial_rec B)
         (grp_trivial_corec B&#39;))
      (inclusion E $o ab_biprod_pr1) ab_biprod_pr2
      ((<span class="kr">fun</span> <span class="nv">x0</span> : grp_prod A B&#39; =&gt;
        (<span class="kr">let</span> <span class="nv">X</span> :=
           <span class="kr">fun</span> <span class="nv">E</span> : AbSES&#39; B A =&gt;
           pointed_fun (iscomplex_abses E) <span class="kr">in</span>
         X E (fst x0))
        :
        projection E
          ((inclusion E $o ab_biprod_pr1) x0) =
        grp_homo_compose (grp_trivial_rec B)
          (grp_trivial_corec B&#39;) (ab_biprod_pr2 x0))
       :
       projection E o (inclusion E $o ab_biprod_pr1) ==
       grp_homo_compose (grp_trivial_rec B)
         (grp_trivial_corec B&#39;) o ab_biprod_pr2) x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pullback_const</span> `{Univalence} {A B B&#39; : AbGroup}
  : const pt == @abses_pullback A B B&#39; grp_homo_const
  := <span class="kr">fun</span> <span class="nv">x</span> =&gt; (equiv_path_abses_iso (abses_pullback_const&#39; x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkd1"><span class="kn">Lemma</span> <span class="nf">abses_pullback_pconst&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : AbGroup}
  : @pmap_abses_const B&#39; A B A $=&gt;* abses_pullback&#39; grp_homo_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pmap_abses_const $=&gt;* abses_pullback&#39; grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkd2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pmap_abses_const $=&gt;* abses_pullback&#39; grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkd3">srefine (_; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pmap_abses_const $=&gt; abses_pullback&#39; grp_homo_const</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chkd4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkd4"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">eta</span> : pmap_abses_const $=&gt;
         abses_pullback&#39; grp_homo_const =&gt;
 eta pt $==
 bp_pointed pmap_abses_const $@
 (bp_pointed (abses_pullback&#39; grp_homo_const))^$)
  <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkd5"><span class="mi">1</span>: rapply abses_pullback_const&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">eta</span> : pmap_abses_const $=&gt;
         abses_pullback&#39; grp_homo_const =&gt;
 eta pt $==
 bp_pointed pmap_abses_const $@
 (bp_pointed (abses_pullback&#39; grp_homo_const))^$)
  abses_pullback_const&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkd6"><span class="nb">lazy</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_const&#39; pt $==
bp_pointed pmap_abses_const $@
(bp_pointed (abses_pullback&#39; grp_homo_const))^$</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkd7"><span class="kn">Definition</span> <span class="nf">abses_pullback_pconst</span> `{Univalence} {A B B&#39; : AbGroup}
  : pconst ==* @abses_pullback_pmap _ A B B&#39; grp_homo_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pconst ==* abses_pullback_pmap grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkd8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pconst ==* abses_pullback_pmap grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkd9"><span class="nb">refine</span> (pmap_abses_const_to_pointed @* _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_pointed pmap_abses_const ==*
abses_pullback_pmap grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkda">rapply equiv_ptransformation_phomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pmap_abses_const $=&gt;* abses_pullback&#39; grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> abses_pullback_pconst&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Pulling [E] back along [projection E] is trivial *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkdb"><span class="kn">Definition</span> <span class="nf">abses_pullback_projection_morphism</span> {<span class="nv">B</span> <span class="nv">A</span> : AbGroup} (<span class="nv">E</span> : AbSES B A)
  : AbSESMorphism (pt : AbSES E A) E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism (pt : AbSES E A) E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkdc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">AbSESMorphism (pt : AbSES E A) E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkdd">srapply (Build_AbSESMorphism grp_homo_id _ (projection E)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pt $-&gt; E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chkde" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkde"><hr></label><div class="goal-conclusion">inclusion E $o grp_homo_id ==
<span class="nl">?component2</span> $o inclusion pt</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chkdf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkdf"><hr></label><div class="goal-conclusion">projection E $o <span class="nl">?component2</span> ==
projection E $o projection pt</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chke0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pt $-&gt; E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chke1"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (grp_prod A E) E</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ab_biprod_rec (inclusion E) grp_homo_id).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chke2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion E $o grp_homo_id ==
(ab_biprod_rec (inclusion E) grp_homo_id : pt $-&gt; E) $o
inclusion pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chke3"><span class="nb">intro</span> x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inclusion E x = sg_op (inclusion E x) group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (right_identity _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chke4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E $o
(ab_biprod_rec (inclusion E) grp_homo_id : pt $-&gt; E) ==
projection E $o projection pt</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chke5"><span class="nb">intros</span> [a e]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (sg_op (inclusion E a) e) =
projection E e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chke6"><span class="nb">refine</span> (grp_homo_op _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op (projection E (inclusion E a)) (projection E e) =
projection E e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chke7"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; sg_op x _) _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E (inclusion E a) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chke8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><label class="goal-separator" for="pullback-v-chke8"><hr></label><div class="goal-conclusion">sg_op <span class="nl">?Goal</span> (projection E e) = projection E e</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chke9"><span class="mi">1</span>: <span class="nb">apply</span> isexact_inclusion_projection.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>B, A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op (pconst a) (projection E e) = projection E e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> left_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pullback_projection</span> `{Univalence} {B A : AbGroup} (E : AbSES B A)
  : pt = abses_pullback (projection E) E
  := abses_pullback_component1_id
       (abses_pullback_projection_morphism E) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Pulling back along homotopic maps *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkea"><span class="kn">Lemma</span> <span class="nf">abses_pullback_homotopic&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : AbGroup}
  (<span class="nv">f</span> <span class="nv">f&#39;</span> : B $-&gt; B&#39;) (<span class="nv">h</span> : f == f&#39;)
  : abses_pullback (A:=A) f $=&gt; abses_pullback f&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f $=&gt; abses_pullback f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkeb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f $=&gt; abses_pullback f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkec"><span class="nb">intro</span> E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f E $-&gt; abses_pullback f&#39; E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chked">srefine (_; (_, _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (abses_pullback f E)
  (abses_pullback f&#39; E)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chkee" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkee"><hr></label><div class="goal-conclusion"><span class="nl">?proj1</span> $o inclusion (abses_pullback f E) ==
inclusion (abses_pullback f&#39; E)</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chkef" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkef"><hr></label><div class="goal-conclusion">projection (abses_pullback f E) ==
projection (abses_pullback f&#39; E) $o <span class="nl">?proj1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkf0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (abses_pullback f E)
  (abses_pullback f&#39; E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkf1">srapply equiv_functor_grp_pullback.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism B&#39; B&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chkf2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkf2"><hr></label><div class="goal-conclusion">GroupIsomorphism E E</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chkf3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkf3"><hr></label><div class="goal-conclusion">GroupIsomorphism B B</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chkf4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkf4"><hr></label><div class="goal-conclusion">projection E o <span class="nl">?beta</span> == <span class="nl">?alpha</span> o projection E</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chkf5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkf5"><hr></label><div class="goal-conclusion"><span class="nl">?alpha</span> o f == f&#39; o <span class="nl">?gamma</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkf6"><span class="mi">1</span>-<span class="mi">3</span>: <span class="bp">exact</span> grp_iso_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E o grp_iso_id == grp_iso_id o projection E</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chkf7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><label class="goal-separator" for="pullback-v-chkf7"><hr></label><div class="goal-conclusion">grp_iso_id o f == f&#39; o grp_iso_id</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkf8"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_iso_id o f == f&#39; o grp_iso_id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkf9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_functor_grp_pullback (projection E)
  (projection E) f f&#39; grp_iso_id grp_iso_id grp_iso_id
  (<span class="kr">fun</span> <span class="nv">x0</span> : E =&gt; <span class="mi">1</span>) h $o
inclusion (abses_pullback f E) ==
inclusion (abses_pullback f&#39; E)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkfa"><span class="nb">intro</span> a; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(inclusion E a; group_unit;
(<span class="mi">1</span> @ ap idmap (cx_isexact a @ (grp_homo_unit f)^)) @
h group_unit) =
(inclusion E a; group_unit;
cx_isexact a @ (grp_homo_unit f&#39;)^)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> srapply equiv_path_pullback_hset; <span class="nb">split</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkfb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection (abses_pullback f E) ==
projection (abses_pullback f&#39; E) $o
equiv_functor_grp_pullback (projection E)
  (projection E) f f&#39; grp_iso_id grp_iso_id grp_iso_id
  (<span class="kr">fun</span> <span class="nv">x0</span> : E =&gt; <span class="mi">1</span>) h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkfc"><span class="kn">Lemma</span> <span class="nf">abses_pullback_homotopic</span> `{Univalence} {A B B&#39; : AbGroup}
  (f f&#39; : B $-&gt; B&#39;) (h : f == f&#39;)
  : abses_pullback (A:=A) f == abses_pullback f&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f == abses_pullback f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkfd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f == abses_pullback f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkfe"><span class="nb">intro</span> E.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f E = abses_pullback f&#39; E</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chkff"><span class="nb">apply</span> equiv_path_abses_iso.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_path_data_iso (abses_pullback f E)
  (abses_pullback f&#39; E)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (abses_pullback_homotopic&#39; _ _ h _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk100"><span class="kn">Lemma</span> <span class="nf">abses_pullback_phomotopic&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : AbGroup}
  (<span class="nv">f</span> <span class="nv">f&#39;</span> : B $-&gt; B&#39;) (<span class="nv">h</span> : f == f&#39;)
  : abses_pullback&#39; (A:=A) f $=&gt;* abses_pullback&#39; f&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback&#39; f $=&gt;* abses_pullback&#39; f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk101"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback&#39; f $=&gt;* abses_pullback&#39; f&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk102"><span class="kr">exists</span> (<span class="nv">abses_pullback_homotopic&#39;</span> <span class="nv">f</span> <span class="nv">f&#39;</span> <span class="nv">h</span>); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Pullback snd f =&gt;
 (pullback_pr1 x; pullback_pr2 x;
 (<span class="mi">1</span> @ ap idmap (pullback_commsq snd f x)) @
 h (pullback_pr2 x))) ==
(<span class="kr">fun</span> <span class="nv">x</span> : Pullback snd f =&gt;
 ((fst (pullback_pr1 x), f&#39; (pullback_pr2 x));
 pullback_pr2 x; <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk103"><span class="nb">intros</span> [[a b&#39;] [b c]]; <span class="nb">cbn</span> <span class="kr">in</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>b&#39; = f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pullback_pr1 ((a, b&#39;); b; c);
pullback_pr2 ((a, b&#39;); b; c);
(<span class="mi">1</span> @ ap idmap (pullback_commsq snd f ((a, b&#39;); b; c))) @
h (pullback_pr2 ((a, b&#39;); b; c))) =
((fst (pullback_pr1 ((a, b&#39;); b; c)),
 f&#39; (pullback_pr2 ((a, b&#39;); b; c)));
pullback_pr2 ((a, b&#39;); b; c); <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk104">srapply equiv_path_pullback_hset; <span class="nb">split</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>b&#39; = f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a, b&#39;) = (a, f&#39; b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk105" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>b&#39; = f b</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk105"><hr></label><div class="goal-conclusion">b = b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk106"><span class="mi">2</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, f'</var><span class="hyp-type"><b>: </b><span>B $-&gt; B&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>f == f&#39;</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>B&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>b&#39; = f b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a, b&#39;) = (a, f&#39; b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_prod&#39; idpath (c @ h b)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abses_pullback_phomotopic</span> `{Univalence} {A B B&#39; : AbGroup}
  (f f&#39; : B $-&gt; B&#39;) (h : f == f&#39;)
  : abses_pullback_pmap (A:=A) f ==* abses_pullback_pmap f&#39;
  := equiv_ptransformation_phomotopy (abses_pullback_phomotopic&#39; f f&#39; h).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Pulling back along a complex *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk107"><span class="kn">Definition</span> <span class="nf">iscomplex_abses_pullback&#39;</span> {<span class="nv">A</span> <span class="nv">B0</span> <span class="nv">B1</span> <span class="nv">B2</span> : AbGroup}
  (<span class="nv">f</span> : B0 $-&gt; B1) (<span class="nv">g</span> : B1 $-&gt; B2) (<span class="nv">h</span> : g $o f == grp_homo_const)
  : abses_pullback&#39; f $o* abses_pullback&#39; g $=&gt;* @pmap_abses_const _ _ _ A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g $o f == grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback&#39; f $o* abses_pullback&#39; g $=&gt;*
pmap_abses_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk108"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g $o f == grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback&#39; f $o* abses_pullback&#39; g $=&gt;*
pmap_abses_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk109"><span class="nb">refine</span> (abses_pullback_pcompose&#39; _ _ $@* _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g $o f == grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback&#39; (g $o f) $=&gt;* pmap_abses_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk10a"><span class="nb">refine</span> (abses_pullback_phomotopic&#39; _ _ h $@* _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g $o f == grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback&#39; grp_homo_const $=&gt;* pmap_abses_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> abses_pullback_pconst&#39;^*$.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk10b"><span class="kn">Definition</span> <span class="nf">iscomplex_abses_pullback</span> `{Univalence} {A B0 B1 B2 : AbGroup}
  (f : B0 $-&gt; B1) (g : B1 $-&gt; B2) (h : g $o f == grp_homo_const)
  : IsComplex (abses_pullback_pmap (A:=A) g) (abses_pullback_pmap f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g $o f == grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (abses_pullback_pmap g)
  (abses_pullback_pmap f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk10c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g $o f == grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (abses_pullback_pmap g)
  (abses_pullback_pmap f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk10d"><span class="nb">refine</span> (_ @* _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g $o f == grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_pmap f o* abses_pullback_pmap g ==*
<span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk10e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g $o f == grp_homo_const</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk10e"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> ==* pconst</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk10f"><span class="mi">2</span>: <span class="nb">symmetry</span>; <span class="bp">exact</span> pmap_abses_const_to_pointed.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g $o f == grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_pmap f o* abses_pullback_pmap g ==*
to_pointed pmap_abses_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk110"><span class="nb">refine</span> (to_pointed_compose _ _ @* _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g $o f == grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">to_pointed (abses_pullback&#39; f $o* abses_pullback&#39; g) ==*
to_pointed pmap_abses_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk111"><span class="nb">apply</span> equiv_ptransformation_phomotopy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B0, B1, B2</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B0 $-&gt; B1</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B1 $-&gt; B2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>g $o f == grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback&#39; f $o* abses_pullback&#39; g $=&gt;*
pmap_abses_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> rapply iscomplex_abses_pullback&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A consequence is that pulling back along a short exact sequence forms a complex. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk112"><span class="kn">Definition</span> <span class="nf">iscomplex_pullback_abses</span> `{Univalence} {A B C : AbGroup} (E : AbSES C B)
  : IsComplex (abses_pullback_pmap (A:=A) (projection E)) (abses_pullback_pmap (inclusion E)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (abses_pullback_pmap (projection E))
  (abses_pullback_pmap (inclusion E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk113"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsComplex (abses_pullback_pmap (projection E))
  (abses_pullback_pmap (inclusion E))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk114">rapply iscomplex_abses_pullback.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>AbSES C B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">projection E $o inclusion E == grp_homo_const</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply iscomplex_abses.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** In fact, pulling back along a short exact sequence is (purely) exact. See [AbSES.PullbackFiberSequence]. *)</span>

<span class="sd">(** *** Fibers of pullback in terms of path data *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_hfiber_abses</span> `{Univalence} {X : <span class="kt">Type</span>} {A B : AbGroup}
  (f : X -&gt; AbSES B A) (E : AbSES B A)
  : graph_hfiber f E &lt;~&gt; hfiber f E
  := equiv_functor_sigma_id (<span class="kr">fun</span> <span class="nv">_</span> =&gt; equiv_path_abses_iso).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">hfiber_abses_path</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">B&#39;</span> : AbGroup} {<span class="nv">f</span> : B&#39; $-&gt; B} {<span class="nv">X</span> : AbSES B&#39; A}
  (<span class="nv">E</span> <span class="nv">F</span> : graph_hfiber (abses_pullback f) X)
  := {p : E.<span class="mi">1</span> $-&gt; F.<span class="mi">1</span> &amp; (fmap (abses_pullback f) p)^$ $@ E.<span class="mi">2</span> $-&gt; F.<span class="mi">2</span>}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk115"><span class="kn">Definition</span> <span class="nf">transport_path_data_hfiber_abses_pullback_l</span> `{Univalence} {A B B&#39; : AbGroup} {f : B&#39; $-&gt; B}
  {Y : AbSES B&#39; A} {X0 : graph_hfiber (abses_pullback f) Y} {X1 : AbSES B A} (p : X0.<span class="mi">1</span> = X1)
  : transport (<span class="kr">fun</span> <span class="nv">x</span> : AbSES B A =&gt; abses_pullback f x $== Y) p X0.<span class="mi">2</span>
    = fmap (abses_pullback f) (equiv_path_abses_iso^-<span class="mi">1</span> p^) $@ X0.<span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>X0.<span class="mi">1</span> = X1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : AbSES B A =&gt; abses_pullback f x $== Y) p
  X0.<span class="mi">2</span> =
fmap (abses_pullback f) (equiv_path_abses_iso^-<span class="mi">1</span> p^) $@
X0.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk116"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>X1</var><span class="hyp-type"><b>: </b><span>AbSES B A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>X0.<span class="mi">1</span> = X1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : AbSES B A =&gt; abses_pullback f x $== Y) p
  X0.<span class="mi">2</span> =
fmap (abses_pullback f) (equiv_path_abses_iso^-<span class="mi">1</span> p^) $@
X0.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk117"><span class="nb">induction</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : AbSES B A =&gt; abses_pullback f x $== Y) <span class="mi">1</span>
  X0.<span class="mi">2</span> =
fmap (abses_pullback f) (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>^) $@
X0.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk118"><span class="nb">refine</span> (transport_1 _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X0.<span class="mi">2</span> =
fmap (abses_pullback f) (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>^) $@
X0.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk119">nrefine (_ @ (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x $@ _)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X0.<span class="mi">2</span> = <span class="nl">?Goal0</span> $@ X0.<span class="mi">2</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk11a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk11a"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> =
fmap (abses_pullback f) (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>^)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk11b"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal0</span> =
fmap (abses_pullback f) (equiv_path_abses_iso^-<span class="mi">1</span> <span class="mi">1</span>^)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk11c"><span class="nb">refine</span> (_ @ ap _ equiv_path_absesV_1^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?Goal0</span> = fmap (abses_pullback f) (Id X0.<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fmap_id_strong _ _)^.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk11d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">X0.<span class="mi">2</span> = Id (abses_pullback f X0.<span class="mi">1</span>) $@ X0.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (cat_idr_strong _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk11e"><span class="kn">Definition</span> <span class="nf">equiv_hfiber_abses_pullback</span> `{Univalence} {A B B&#39; : AbGroup} {f : B&#39; $-&gt; B}
  (Y : AbSES B&#39; A) (U V : graph_hfiber (abses_pullback f) Y)
  : hfiber_abses_path U V &lt;~&gt; U = V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber_abses_path U V &lt;~&gt; U = V</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk11f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber_abses_path U V &lt;~&gt; U = V</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk120"><span class="nb">refine</span> (equiv_path_sigma _ _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber_abses_path U V &lt;~&gt;
{p : U.<span class="mi">1</span> = V.<span class="mi">1</span> &amp;
transport
  (<span class="kr">fun</span> <span class="nv">b</span> : AbSES B A =&gt; abses_pullback f b $-&gt; Y) p
  U.<span class="mi">2</span> = V.<span class="mi">2</span>}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk121">srapply (equiv_functor_sigma&#39; equiv_path_abses_iso);
    <span class="nb">intro</span> p; <span class="nb">lazy</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((fmap (abses_pullback f) p)^$ $@ U.<span class="mi">2</span> $-&gt; V.<span class="mi">2</span>) &lt;~&gt;
transport
  (<span class="kr">fun</span> <span class="nv">b</span> : AbSES B A =&gt; abses_pullback f b $-&gt; Y)
  (equiv_path_abses_iso p) U.<span class="mi">2</span> = V.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk122"><span class="nb">refine</span> (equiv_concat_l _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">b</span> : AbSES B A =&gt; abses_pullback f b $-&gt; Y)
  (equiv_path_abses_iso p) U.<span class="mi">2</span> = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk123" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="pullback-v-chk123"><hr></label><div class="goal-conclusion">((fmap (abses_pullback f) p)^$ $@ U.<span class="mi">2</span> $-&gt; V.<span class="mi">2</span>) &lt;~&gt;
<span class="nl">?Goal</span> = V.<span class="mi">2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk124">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">b</span> : AbSES B A =&gt; abses_pullback f b $-&gt; Y)
  (equiv_path_abses_iso p) U.<span class="mi">2</span> = <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk125"><span class="nb">refine</span> (transport_path_data_hfiber_abses_pullback_l _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pullback f)
  (equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso p)^) $@
U.<span class="mi">2</span> = <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk126"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (fmap (abses_pullback f) x) $@ _) _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso p)^ =
<span class="nl">?Goal1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk127" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="pullback-v-chk127"><hr></label><div class="goal-conclusion">fmap (abses_pullback f) <span class="nl">?Goal1</span> $@ U.<span class="mi">2</span> = <span class="nl">?Goal</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk128">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso^-<span class="mi">1</span> (equiv_path_abses_iso p)^ =
<span class="nl">?Goal1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk129"><span class="nb">refine</span> (ap _ (abses_path_data_V p) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_abses_iso^-<span class="mi">1</span>
  (equiv_path_abses_iso (abses_path_data_inverse p)) =
<span class="nl">?Goal1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eissect.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk12a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pullback f) (abses_path_data_inverse p) $@
U.<span class="mi">2</span> = <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk12b"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x $@ _) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmap (abses_pullback f) (abses_path_data_inverse p) =
<span class="nl">?Goal0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">tapply gpd_strong_1functor_V.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk12c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((fmap (abses_pullback f) p)^$ $@ U.<span class="mi">2</span> $-&gt; V.<span class="mi">2</span>) &lt;~&gt;
(fmap (abses_pullback f) p)^$ $@ U.<span class="mi">2</span> = V.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk12d"><span class="nb">refine</span> (equiv_path_sigma_hprop _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B&#39; $-&gt; B</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span>AbSES B&#39; A</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span>graph_hfiber (abses_pullback f) Y</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>abses_path_data_iso U.<span class="mi">1</span> V.<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((fmap (abses_pullback f) p)^$ $@ U.<span class="mi">2</span> $-&gt; V.<span class="mi">2</span>) &lt;~&gt;
((fmap (abses_pullback f) p)^$ $@ U.<span class="mi">2</span>).<span class="mi">1</span> = (V.<span class="mi">2</span>).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_path_groupisomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** [AbSES] and [AbSES&#39;] become contravariant functors in the first variable by pulling back *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk12e"><span class="kn">Instance</span> <span class="nf">is0functor_abses&#39;10</span> {<span class="nv">A</span> : AbGroup}
  : Is0Functor (<span class="kr">fun</span> <span class="nv">B</span> : AbGroup^op =&gt; AbSES&#39; B A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (<span class="kr">fun</span> <span class="nv">B</span> : AbGroup^op =&gt; AbSES&#39; B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk12f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (<span class="kr">fun</span> <span class="nv">B</span> : AbGroup^op =&gt; AbSES&#39; B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk130"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : AbGroup^op,
(a $-&gt; b) -&gt; AbSES&#39; a A $-&gt; AbSES&#39; b A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">f</span> =&gt; abses_pullback f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk131"><span class="kn">Instance</span> <span class="nf">is1functor_abses&#39;10</span> `{Univalence} {A : AbGroup}
  : Is1Functor (<span class="kr">fun</span> <span class="nv">B</span> : AbGroup^op =&gt; AbSES&#39; B A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (<span class="kr">fun</span> <span class="nv">B</span> : AbGroup^op =&gt; AbSES&#39; B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk132"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (<span class="kr">fun</span> <span class="nv">B</span> : AbGroup^op =&gt; AbSES&#39; B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk133"><span class="nb">apply</span> Build_Is1Functor; <span class="nb">intros</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f == abses_pullback g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk134" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk134"><hr></label><div class="goal-conclusion">abses_pullback grp_homo_id == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk135" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b $-&gt; c</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk135"><hr></label><div class="goal-conclusion">abses_pullback (grp_homo_compose f g) ==
(<span class="kr">fun</span> <span class="nv">x</span> : AbSES&#39; a A =&gt;
 abses_pullback g (abses_pullback f x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk136">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback f == abses_pullback g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> abses_pullback_homotopic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk137">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback grp_homo_id == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> abses_pullback_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk138">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b $-&gt; c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback (grp_homo_compose f g) ==
(<span class="kr">fun</span> <span class="nv">x</span> : AbSES&#39; a A =&gt;
 abses_pullback g (abses_pullback f x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> abses_pullback_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk139"><span class="kn">Instance</span> <span class="nf">is0functor_abses10</span> `{Univalence} {A : AbGroup}
  : Is0Functor (<span class="kr">fun</span> <span class="nv">B</span> : AbGroup^op =&gt; AbSES B A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (<span class="kr">fun</span> <span class="nv">B</span> : AbGroup^op =&gt; AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk13a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (<span class="kr">fun</span> <span class="nv">B</span> : AbGroup^op =&gt; AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk13b"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : AbGroup^op,
(a $-&gt; b) -&gt; AbSES a A $-&gt; AbSES b A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">f</span> =&gt; abses_pullback_pmap f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk13c"><span class="kn">Instance</span> <span class="nf">is1functor_abses10</span> `{Univalence} {A : AbGroup}
  : Is1Functor (<span class="kr">fun</span> <span class="nv">B</span> : AbGroup^op =&gt; AbSES B A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (<span class="kr">fun</span> <span class="nv">B</span> : AbGroup^op =&gt; AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk13d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (<span class="kr">fun</span> <span class="nv">B</span> : AbGroup^op =&gt; AbSES B A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk13e"><span class="nb">apply</span> Build_Is1Functor; <span class="nb">intros</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_pmap f ==* abses_pullback_pmap g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="pullback-v-chk13f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk13f"><hr></label><div class="goal-conclusion">abses_pullback_pmap grp_homo_id ==* pmap_idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="pullback-v-chk140" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b $-&gt; c</span></span></span><br></div><label class="goal-separator" for="pullback-v-chk140"><hr></label><div class="goal-conclusion">abses_pullback_pmap (grp_homo_compose f g) ==*
abses_pullback_pmap g o* abses_pullback_pmap f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk141">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>f $== g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_pmap f ==* abses_pullback_pmap g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> abses_pullback_phomotopic.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk142">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_pmap grp_homo_id ==* pmap_idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> abses_pullback_pmap_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="pullback-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="pullback-v-chk143">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>AbGroup^op</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>a $-&gt; b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>b $-&gt; c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">abses_pullback_pmap (grp_homo_compose f g) ==*
abses_pullback_pmap g o* abses_pullback_pmap f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> abses_pullback_pcompose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
