<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>quotient.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkb3"><span class="kn">Require Import</span> HoTT.Basics HoTT.Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> HSet TruncType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * The set-quotient of a type by an hprop-valued relation</span>

<span class="sd">We aim to model:</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">Inductive quotient : Type :=</span>
<span class="sd">   | class_of : A -&gt; quotient</span>
<span class="sd">   | related_classes_eq : forall x y, (R x y), class_of x = class_of y</span>
<span class="sd">   | quotient_set : IsHSet quotient</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">*)</span>

<span class="sd">(** TODO:  This development should be further connected with the sections in the book; see below.  And it should be merged with Colimits.Quotient. Currently this file is only used in Classes/implementations/natpair_integers.v and Classes/implementations/field_of_fractions.v, so it shouldn&#39;t be too hard to switch to Colimits.Quotient. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Export</span> Quotient.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Domain</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">Universes i j u.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Constraint</span> <span class="nf">i</span> &lt;= u, j &lt;= u.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> : <span class="kt">Type</span>@{i}} (<span class="nv">R</span> : Relation@{i j} A) {<span class="nv">sR</span>: is_mere_relation _ R}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** We choose to let the definition of quotient depend on the proof that [R] is a set-relations.  Alternatively, we could have defined it for all relations and only develop the theory for set-relations.  The former seems more natural.</span>

<span class="sd">We do not require [R] to be an equivalence relation, but implicitly consider its transitive-reflexive closure. *)</span>

    <span class="sd">(** This definition has a parameter [sR] that shadows the ambient one in the Context in order to ensure that it actually ends up depending on everything in the Context when the section is closed, since its definition doesn&#39;t actually refer to any of them.  *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">Private <span class="kn">Inductive</span> <span class="nf">quotient</span> {<span class="nv">sR</span>: is_mere_relation _ R} : <span class="kt">Type</span>@{u} :=
    | class_of : A -&gt; quotient.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** The path constructors. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">related_classes_eq</span>
    : <span class="kr">forall</span> {<span class="nv">x</span> <span class="nv">y</span> : A}, R x y -&gt;
                        class_of x = class_of y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">quotient_set</span> : IsHSet (@quotient sR).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Existing Instance</span> <span class="nf">quotient_set</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">quotient_ind</span> (<span class="nv">P</span> : (@quotient sR) -&gt; <span class="kt">Type</span>) {<span class="nv">sP</span> : <span class="kr">forall</span> <span class="nv">x</span>, IsHSet (P x)}
               (<span class="nv">dclass</span> : <span class="kr">forall</span> <span class="nv">x</span>, P (class_of x))
               (<span class="nv">dequiv</span> : (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> (<span class="nv">H</span> : R x y), (related_classes_eq H) # (dclass x) = dclass y))
    : <span class="kr">forall</span> <span class="nv">q</span>, P q
      := <span class="kr">fun</span> <span class="nv">q</span> =&gt; <span class="kr">match</span> q <span class="kr">with</span> class_of a =&gt; <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; dclass a <span class="kr">end</span> sP dequiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkb4"><span class="kn">Definition</span> <span class="nf">quotient_ind_compute</span> {<span class="nv">P</span> <span class="nv">sP</span>} <span class="nv">dclass</span> <span class="nv">dequiv</span> <span class="nv">x</span>
    : @quotient_ind P sP dclass dequiv (class_of x) = dclass x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>quotient -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : quotient, IsHSet (P x)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of x)</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y),
transport P (related_classes_eq H) (dclass x) =
dclass y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient_ind P dclass dequiv (class_of x) = dclass x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkb5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>quotient -&gt; <span class="kt">Type</span></span></span></span><br><span><var>sP</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : quotient, IsHSet (P x)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of x)</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y),
transport P (related_classes_eq H) (dclass x) =
dclass y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient_ind P dclass dequiv (class_of x) = dclass x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Again equality of paths needs to be postulated *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">quotient_ind_compute_path</span>
    : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">sP</span> <span class="nv">dclass</span> <span class="nv">dequiv</span>,
      <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> (<span class="nv">H</span> : R x y),
        apD (@quotient_ind P sP dclass dequiv) (related_classes_eq H)
        = dequiv x y H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Domain</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Quotient</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Equiv</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Univalence}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : Relation A) {<span class="nv">sR</span>: is_mere_relation _ R}
          {<span class="nv">Htrans</span> : Transitive R} {<span class="nv">Hsymm</span> : Symmetric R}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkb6"><span class="kn">Lemma</span> <span class="nf">quotient_path2</span> : <span class="kr">forall</span> {<span class="nv">x</span> <span class="nv">y</span> : quotient R} (<span class="nv">p</span> <span class="nv">q</span> : x=y), p=q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : quotient R) (<span class="nv">p</span> <span class="nv">q</span> : x = y), p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkb7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : quotient R) (<span class="nv">p</span> <span class="nv">q</span> : x = y), p = q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkb8"><span class="nb">apply</span> @hset_path2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (quotient R)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkb9"><span class="kn">Definition</span> <span class="nf">in_class</span> : quotient R -&gt; A -&gt; HProp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient R -&gt; A -&gt; HProp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkba"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient R -&gt; A -&gt; HProp</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkbb"><span class="nb">refine</span> (quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> =&gt; A -&gt; HProp) (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; Build_HProp (R a b)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y),
transport (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; A -&gt; HProp)
  (related_classes_eq R H)
  (<span class="kr">fun</span> <span class="nv">b</span> : A =&gt; Build_HProp (R x b)) =
(<span class="kr">fun</span> <span class="nv">b</span> : A =&gt; Build_HProp (R y b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkbc"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; A -&gt; HProp)
  (related_classes_eq R H0)
  (<span class="kr">fun</span> <span class="nv">b</span> : A =&gt; Build_HProp (R x b)) =
(<span class="kr">fun</span> <span class="nv">b</span> : A =&gt; Build_HProp (R y b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkbd"><span class="nb">eapply</span> concat;[<span class="nb">apply</span> transport_const|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : A =&gt; Build_HProp (R x b)) =
(<span class="kr">fun</span> <span class="nv">b</span> : A =&gt; Build_HProp (R y b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkbe"><span class="nb">apply</span> path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">b</span> : A =&gt; Build_HProp (R x b)) ==
(<span class="kr">fun</span> <span class="nv">b</span> : A =&gt; Build_HProp (R y b))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkbf"><span class="nb">intro</span> z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Build_HProp (R x z) = Build_HProp (R y z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkc0"><span class="nb">apply</span> path_hprop; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R x z &lt;~&gt; R y z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> @equiv_iff_hprop; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Hrefl</span> : Reflexive R}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkc1"><span class="kn">Lemma</span> <span class="nf">in_class_pr</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, (in_class (class_of R x) y : <span class="kt">Type</span>) = R x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A,
(in_class (class_of R x) y : <span class="kt">Type</span>) = R x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkc2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A,
(in_class (class_of R x) y : <span class="kt">Type</span>) = R x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkc3"><span class="kn">Lemma</span> <span class="nf">quotient_ind_prop</span> (<span class="nv">P</span> : quotient R -&gt; <span class="kt">Type</span>)
        `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)} :
    <span class="kr">forall</span> <span class="nv">dclass</span> : <span class="kr">forall</span> <span class="nv">x</span>, P (class_of R x),
    <span class="kr">forall</span> <span class="nv">q</span>, P q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : quotient R, IsHProp (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of R x)) -&gt;
<span class="kr">forall</span> <span class="nv">q</span> : quotient R, P q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkc4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : quotient R, IsHProp (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of R x)) -&gt;
<span class="kr">forall</span> <span class="nv">q</span> : quotient R, P q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkc5"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : quotient R, IsHProp (P x)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of R x)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>quotient R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P q</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkc6"><span class="nb">apply</span> (quotient_ind R P dclass).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : quotient R, IsHProp (P x)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of R x)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>quotient R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y),
transport P (related_classes_eq R H) (dclass x) =
dclass y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkc7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : quotient R, IsHProp (P x)</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of R x)</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>quotient R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (related_classes_eq R H1) (dclass x) =
dclass y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkc8">#[export] <span class="kn">Instance</span> <span class="nf">decidable_in_class</span> `{<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, Decidable (R x y)}
  : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">a</span>, Decidable (in_class x a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, Decidable (R x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : quotient R) (<span class="nv">a</span> : A),
Decidable (in_class x a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkc9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, Decidable (R x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : quotient R) (<span class="nv">a</span> : A),
Decidable (in_class x a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkca"><span class="nb">refine</span> (quotient_ind_prop _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, Decidable (R x y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">a</span> : A, Decidable (in_class (class_of R x) a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> a b; <span class="bp">exact</span> (transport Decidable (in_class_pr a b) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkcb"><span class="kn">Lemma</span> <span class="nf">class_of_repr</span> : <span class="kr">forall</span> <span class="nv">q</span> <span class="nv">x</span>, in_class q x -&gt; q = class_of R x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">q</span> : quotient R) (<span class="nv">x</span> : A),
in_class q x -&gt; q = class_of R x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkcc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">q</span> : quotient R) (<span class="nv">x</span> : A),
in_class q x -&gt; q = class_of R x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkcd"><span class="nb">apply</span> (quotient_ind R
                        (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt; <span class="kr">forall</span> <span class="nv">x</span>, in_class q x -&gt; q = class_of _ x)
                        (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">H</span> =&gt; related_classes_eq R H)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y),
transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
   <span class="kr">forall</span> <span class="nv">x0</span> : A, in_class q x0 -&gt; q = class_of R x0)
  (related_classes_eq R H)
  (<span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">H0</span> : in_class (class_of R x) y0) =&gt;
   related_classes_eq R H0) =
(<span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">H0</span> : in_class (class_of R y) y0) =&gt;
 related_classes_eq R H0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkce"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
   <span class="kr">forall</span> <span class="nv">x</span> : A, in_class q x -&gt; q = class_of R x)
  (related_classes_eq R H0)
  (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">H</span> : in_class (class_of R x) y) =&gt;
   related_classes_eq R H) =
(<span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">H</span> : in_class (class_of R y) y0) =&gt;
 related_classes_eq R H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkcf"><span class="nb">apply</span> path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
   <span class="kr">forall</span> <span class="nv">x</span> : A, in_class q x -&gt; q = class_of R x)
  (related_classes_eq R H0)
  (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">H</span> : in_class (class_of R x) y) =&gt;
   related_classes_eq R H) ==
(<span class="kr">fun</span> (<span class="nv">y0</span> : A) (<span class="nv">H</span> : in_class (class_of R y) y0) =&gt;
 related_classes_eq R H)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkd0"><span class="nb">intro</span> z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
   <span class="kr">forall</span> <span class="nv">x</span> : A, in_class q x -&gt; q = class_of R x)
  (related_classes_eq R H0)
  (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">H</span> : in_class (class_of R x) y) =&gt;
   related_classes_eq R H) z =
(<span class="kr">fun</span> <span class="nv">H</span> : in_class (class_of R y) z =&gt;
 related_classes_eq R H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkd1"><span class="nb">apply</span> path_forall;<span class="nb">intro</span> H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>in_class (class_of R y) z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
   <span class="kr">forall</span> <span class="nv">x</span> : A, in_class q x -&gt; q = class_of R x)
  (related_classes_eq R H0)
  (<span class="kr">fun</span> (<span class="nv">y</span> : A) (<span class="nv">H</span> : in_class (class_of R x) y) =&gt;
   related_classes_eq R H) z H&#39; =
related_classes_eq R H&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> quotient_path2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkd2"><span class="kn">Lemma</span> <span class="nf">classes_eq_related</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>,
                               class_of R x = class_of R y -&gt; R x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, class_of R x = class_of R y -&gt; R x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkd3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, class_of R x = class_of R y -&gt; R x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkd4"><span class="nb">intros</span> x y H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>class_of R x = class_of R y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkd5"><span class="nb">pattern</span> (R x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>class_of R x = class_of R y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">idmap (R x y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkd6"><span class="nb">eapply</span> transport.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>class_of R x = class_of R y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?T</span> = R x y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chkd7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>class_of R x = class_of R y</span></span></span><br></div><label class="goal-separator" for="quotient-v-chkd7"><hr></label><div class="goal-conclusion"><span class="nl">?T</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkd8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>class_of R x = class_of R y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?T</span> = R x y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> in_class_pr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkd9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>class_of R x = class_of R y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_class (class_of R x) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkda"><span class="nb">pattern</span> (class_of R x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>class_of R x = class_of R y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt; trunctype_type (in_class q y))
  (class_of R x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkdb"><span class="nb">apply</span> (transport _ (H&#39;^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>class_of R x = class_of R y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in_class (class_of R y) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Hrefl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Theorem 10.1.8 *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkdc"><span class="kn">Theorem</span> <span class="nf">sets_exact</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, (class_of R x = class_of R y) &lt;~&gt; R x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, class_of R x = class_of R y &lt;~&gt; R x y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkdd"><span class="nb">intros</span> ??.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R x = class_of R y &lt;~&gt; R x y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkde"><span class="nb">apply</span> equiv_iff_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R x = class_of R y -&gt; R x y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chkdf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="quotient-v-chkdf"><hr></label><div class="goal-conclusion">R x y -&gt; class_of R x = class_of R y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chke0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R x = class_of R y -&gt; R x y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> classes_eq_related.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chke1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R x y -&gt; class_of R x = class_of R y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> related_classes_eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chke2"><span class="kn">Definition</span> <span class="nf">quotient_rec</span> {<span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">sB</span> : IsHSet B}
             (<span class="nv">dclass</span> : (<span class="kr">forall</span> <span class="nv">x</span> : A, B))
             (<span class="nv">dequiv</span> : (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, R x y -&gt; dclass x = dclass y))
  : quotient R -&gt; B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>sB</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y -&gt; dclass x = dclass y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient R -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chke3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>sB</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y -&gt; dclass x = dclass y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient R -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chke4"><span class="nb">apply</span> (quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient _ =&gt; B)) <span class="kr">with</span> dclass.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>sB</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y -&gt; dclass x = dclass y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y),
transport (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B)
  (related_classes_eq R H) (dclass x) = dclass y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chke5"><span class="nb">intros</span> ?? H&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>sB</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y -&gt; dclass x = dclass y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B)
  (related_classes_eq R H&#39;) (dclass x) = dclass y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chke6"><span class="nb">destruct</span> (related_classes_eq R H&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>sB</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y -&gt; dclass x = dclass y</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) <span class="mi">1</span> (dclass x) =
dclass y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> dequiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chke7"><span class="kn">Definition</span> <span class="nf">quotient_rec2</span> {<span class="nv">B</span> : HSet} {<span class="nv">dclass</span> : (A -&gt; A -&gt; B)}:
    <span class="kr">forall</span> <span class="nv">dequiv</span> : (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span>, R x x&#39; -&gt; <span class="kr">forall</span> <span class="nv">y</span> <span class="nv">y&#39;</span>,  R y y&#39; -&gt;
                                                          dclass x y = dclass x&#39; y&#39;),
      quotient R -&gt; quotient R -&gt; B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : A,
 R x x&#39; -&gt;
 <span class="kr">forall</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, R y y&#39; -&gt; dclass x y = dclass x&#39; y&#39;) -&gt;
quotient R -&gt; quotient R -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chke8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : A,
 R x x&#39; -&gt;
 <span class="kr">forall</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A, R y y&#39; -&gt; dclass x y = dclass x&#39; y&#39;) -&gt;
quotient R -&gt; quotient R -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chke9"><span class="nb">intro</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : A,
R x x&#39; -&gt;
<span class="kr">forall</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A,
R y y&#39; -&gt; dclass x y = dclass x&#39; y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient R -&gt; quotient R -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkea"><span class="nb">assert</span> (dequiv0 : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x0</span> <span class="nv">y</span> : A, R x0 y -&gt; dclass x x0 = dclass x y)
      <span class="bp">by</span> (<span class="nb">intros</span> ? ? ? Hx; <span class="nb">apply</span> dequiv;[<span class="nb">apply</span> Hrefl|<span class="bp">done</span>]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : A,
R x x&#39; -&gt;
<span class="kr">forall</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A,
R y y&#39; -&gt; dclass x y = dclass x&#39; y&#39;</span></span></span><br><span><var>dequiv0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x0</span> <span class="nv">y</span> : A,
R x0 y -&gt; dclass x x0 = dclass x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient R -&gt; quotient R -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkeb"><span class="nb">refine</span> (quotient_rec
              (<span class="kr">fun</span> <span class="nv">x</span> =&gt; quotient_rec (dclass x) (dequiv0 x)) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : A,
R x x&#39; -&gt;
<span class="kr">forall</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A,
R y y&#39; -&gt; dclass x y = dclass x&#39; y&#39;</span></span></span><br><span><var>dequiv0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x0</span> <span class="nv">y</span> : A,
R x0 y -&gt; dclass x x0 = dclass x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A,
R x y -&gt;
quotient_rec (dclass x) (dequiv0 x) =
quotient_rec (dclass y) (dequiv0 y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkec"><span class="nb">intros</span> x x&#39; Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : A,
R x x&#39; -&gt;
<span class="kr">forall</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A,
R y y&#39; -&gt; dclass x y = dclass x&#39; y&#39;</span></span></span><br><span><var>dequiv0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x0</span> <span class="nv">y</span> : A,
R x0 y -&gt; dclass x x0 = dclass x y</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>R x x&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient_rec (dclass x) (dequiv0 x) =
quotient_rec (dclass x&#39;) (dequiv0 x&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chked"><span class="nb">apply</span> path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : A,
R x x&#39; -&gt;
<span class="kr">forall</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A,
R y y&#39; -&gt; dclass x y = dclass x&#39; y&#39;</span></span></span><br><span><var>dequiv0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x0</span> <span class="nv">y</span> : A,
R x0 y -&gt; dclass x x0 = dclass x y</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>R x x&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient_rec (dclass x) (dequiv0 x) ==
quotient_rec (dclass x&#39;) (dequiv0 x&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkee"><span class="nb">red</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : A,
R x x&#39; -&gt;
<span class="kr">forall</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A,
R y y&#39; -&gt; dclass x y = dclass x&#39; y&#39;</span></span></span><br><span><var>dequiv0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x0</span> <span class="nv">y</span> : A,
R x0 y -&gt; dclass x x0 = dclass x y</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>R x x&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : quotient R,
quotient_rec (dclass x) (dequiv0 x) x0 =
quotient_rec (dclass x&#39;) (dequiv0 x&#39;) x0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkef"><span class="nb">assert</span> (dequiv1 : <span class="kr">forall</span> <span class="nv">y</span> : A,
                        quotient_rec (dclass x) (dequiv0 x) (class_of _ y) =
                        quotient_rec (dclass x&#39;) (dequiv0 x&#39;) (class_of _ y))
      <span class="bp">by</span> (<span class="nb">intros</span>; <span class="bp">by</span> <span class="nb">apply</span> dequiv).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : A,
R x x&#39; -&gt;
<span class="kr">forall</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A,
R y y&#39; -&gt; dclass x y = dclass x&#39; y&#39;</span></span></span><br><span><var>dequiv0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x0</span> <span class="nv">y</span> : A,
R x0 y -&gt; dclass x x0 = dclass x y</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>R x x&#39;</span></span></span><br><span><var>dequiv1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
quotient_rec (dclass x) 
  (dequiv0 x) (class_of R y) =
quotient_rec (dclass x&#39;) 
  (dequiv0 x&#39;) (class_of R y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : quotient R,
quotient_rec (dclass x) (dequiv0 x) x0 =
quotient_rec (dclass x&#39;) (dequiv0 x&#39;) x0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkf0"><span class="nb">refine</span> (quotient_ind R (<span class="kr">fun</span> <span class="nv">q</span> =&gt;
                              quotient_rec (dclass x) (dequiv0 x) q =
                              quotient_rec (dclass x&#39;) (dequiv0 x&#39;) q) dequiv1 _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : A,
R x x&#39; -&gt;
<span class="kr">forall</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A,
R y y&#39; -&gt; dclass x y = dclass x&#39; y&#39;</span></span></span><br><span><var>dequiv0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x0</span> <span class="nv">y</span> : A,
R x0 y -&gt; dclass x x0 = dclass x y</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>R x x&#39;</span></span></span><br><span><var>dequiv1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
quotient_rec (dclass x) 
  (dequiv0 x) (class_of R y) =
quotient_rec (dclass x&#39;) 
  (dequiv0 x&#39;) (class_of R y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x0</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x0 y),
transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
   quotient_rec (dclass x) (dequiv0 x) q =
   quotient_rec (dclass x&#39;) (dequiv0 x&#39;) q)
  (related_classes_eq R H) (dequiv1 x0) = dequiv1 y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkf1"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; B</span></span></span><br><span><var>dequiv</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x&#39;</span> : A,
R x x&#39; -&gt;
<span class="kr">forall</span> <span class="nv">y</span> <span class="nv">y&#39;</span> : A,
R y y&#39; -&gt; dclass x y = dclass x&#39; y&#39;</span></span></span><br><span><var>dequiv0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">x0</span> <span class="nv">y</span> : A,
R x0 y -&gt; dclass x x0 = dclass x y</span></span></span><br><span><var>x, x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>R x x&#39;</span></span></span><br><span><var>dequiv1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A,
quotient_rec (dclass x) 
  (dequiv0 x) (class_of R y) =
quotient_rec (dclass x&#39;) 
  (dequiv0 x&#39;) (class_of R y)</span></span></span><br><span><var>x0, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>R x0 y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
   quotient_rec (dclass x) (dequiv0 x) q =
   quotient_rec (dclass x&#39;) (dequiv0 x&#39;) q)
  (related_classes_eq R H0) (dequiv1 x0) = dequiv1 y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkf2"><span class="kn">Definition</span> <span class="nf">quotient_ind_prop&#39;</span> : <span class="kr">forall</span> <span class="nv">P</span> : quotient R -&gt; <span class="kt">Type</span>,
                                  <span class="kr">forall</span> (<span class="nv">Hprop&#39;</span> : <span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P (class_of _ x))),
                                    (<span class="kr">forall</span> <span class="nv">x</span>, P (class_of _ x)) -&gt; <span class="kr">forall</span> <span class="nv">y</span>, P y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : quotient R -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P (class_of R x))) -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of R x)) -&gt;
<span class="kr">forall</span> <span class="nv">y</span> : quotient R, P y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkf3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : quotient R -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P (class_of R x))) -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of R x)) -&gt;
<span class="kr">forall</span> <span class="nv">y</span> : quotient R, P y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkf4"><span class="nb">intros</span> ? ? dclass.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Hprop'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P (class_of R x))</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of R x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : quotient R, P y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkf5"><span class="nb">apply</span> quotient_ind <span class="kr">with</span> dclass.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Hprop'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P (class_of R x))</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of R x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : quotient R, IsHSet (P x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chkf6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Hprop'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P (class_of R x))</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of R x)</span></span></span><br></div><label class="goal-separator" for="quotient-v-chkf6"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y),
transport P (related_classes_eq R H) (dclass x) =
dclass y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkf7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Hprop'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P (class_of R x))</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of R x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : quotient R, IsHSet (P x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkf8"><span class="nb">simple refine</span> (quotient_ind R (<span class="kr">fun</span> <span class="nv">x</span> =&gt; IsHSet (P x)) _ _); <span class="nb">cbn</span> beta; <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Hprop'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P (class_of R x))</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of R x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y),
transport (<span class="kr">fun</span> <span class="nv">x0</span> : quotient R =&gt; IsHSet (P x0))
  (related_classes_eq R H)
  ((<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; istrunc_hprop) x) =
(<span class="kr">fun</span> <span class="nv">x0</span> : A =&gt; istrunc_hprop) y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkf9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Hprop'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P (class_of R x))</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of R x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y),
transport P (related_classes_eq R H) (dclass x) =
dclass y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkfa"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; <span class="kt">Type</span></span></span></span><br><span><var>Hprop'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, IsHProp (P (class_of R x))</span></span></span><br><span><var>dclass</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, P (class_of R x)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (related_classes_eq R H0) (dclass x) =
dclass y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** From Ch6 *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkfb"><span class="kn">Theorem</span> <span class="nf">quotient_surjective</span>: IsSurjection (class_of R).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) (class_of R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkfc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) (class_of R)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkfd"><span class="nb">apply</span> BuildIsSurjection.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : quotient R, merely (hfiber (class_of R) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkfe"><span class="nb">apply</span> (quotient_ind_prop (<span class="kr">fun</span> <span class="nv">y</span> =&gt; merely (hfiber (class_of R) y))); <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
merely (hfiber (class_of R) (class_of R x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chkff"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (hfiber (class_of R) (class_of R x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk100"><span class="nb">apply</span> tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (class_of R) (class_of R x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** From Ch10 *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk101"><span class="kn">Definition</span> <span class="nf">quotient_ump&#39;</span> (<span class="nv">B</span>:HSet): (quotient R -&gt; B) -&gt;
                                     (sig (<span class="kr">fun</span> <span class="nv">f</span> : A-&gt; B =&gt; (<span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a0</span>:A, R a a0 -&gt; f a =f a0))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(quotient R -&gt; B) -&gt;
{f : A -&gt; B &amp; <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a0</span> : A, R a a0 -&gt; f a = f a0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk102"><span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : A -&gt; B &amp; <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a0</span> : A, R a a0 -&gt; f a = f a0}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk103"><span class="kr">exists</span> (<span class="nv">compose</span> <span class="nv">f</span> (class_of R) ).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a0</span> : A,
R a a0 -&gt; f (class_of R a) = f (class_of R a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk104"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; B</span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>R a a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (class_of R a) = f (class_of R a0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk105">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; B</span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>R a a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R a = class_of R a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> related_classes_eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk106"><span class="kn">Definition</span> <span class="nf">quotient_ump&#39;&#39;</span> (<span class="nv">B</span>:HSet): (sig (<span class="kr">fun</span> <span class="nv">f</span> : A-&gt; B =&gt; (<span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a0</span>:A, R a a0 -&gt; f a =f a0)))
                                      -&gt; quotient R -&gt; B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : A -&gt; B &amp; <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a0</span> : A, R a a0 -&gt; f a = f a0} -&gt;
quotient R -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk107"><span class="nb">intros</span> [f H&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H'</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a0</span> : A, R a a0 -&gt; f a = f a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient R -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (quotient_rec _ H&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk108"><span class="kn">Theorem</span> <span class="nf">quotient_ump</span> (<span class="nv">B</span>:HSet): (quotient R -&gt; B) &lt;~&gt;
                                                   (sig (<span class="kr">fun</span> <span class="nv">f</span> : A-&gt; B =&gt; (<span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a0</span>:A, R a a0 -&gt; f a =f a0))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(quotient R -&gt; B) &lt;~&gt;
{f : A -&gt; B &amp; <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a0</span> : A, R a a0 -&gt; f a = f a0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk109"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(quotient R -&gt; B) &lt;~&gt;
{f : A -&gt; B &amp; <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a0</span> : A, R a a0 -&gt; f a = f a0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk10a"><span class="nb">refine</span> (equiv_adjointify (quotient_ump&#39; B) (quotient_ump&#39;&#39; B) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">x</span> : {f : A -&gt; B &amp;
       <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a0</span> : A, R a a0 -&gt; f a = f a0} =&gt;
 quotient_ump&#39; B (quotient_ump&#39;&#39; B x)) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk10b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk10b"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : quotient R -&gt; B =&gt;
 quotient_ump&#39;&#39; B (quotient_ump&#39; B x)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk10c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">x</span> : {f : A -&gt; B &amp;
       <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a0</span> : A, R a a0 -&gt; f a = f a0} =&gt;
 quotient_ump&#39; B (quotient_ump&#39;&#39; B x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk10d"><span class="nb">intros</span> [f Hf].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">a0</span> : A, R a a0 -&gt; f a = f a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient_ump&#39; B (quotient_ump&#39;&#39; B (f; Hf)) = (f; Hf)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> equiv_path_sigma_hprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk10e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : quotient R -&gt; B =&gt;
 quotient_ump&#39;&#39; B (quotient_ump&#39; B x)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk10f"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient_ump&#39;&#39; B (quotient_ump&#39; B f) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk110"><span class="nb">apply</span> path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient_ump&#39;&#39; B (quotient_ump&#39; B f) == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk111"><span class="nb">red</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>Hsymm</var><span class="hyp-type"><b>: </b><span>Symmetric R</span></span></span><br><span><var>Hrefl</var><span class="hyp-type"><b>: </b><span>Reflexive R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>HSet</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>quotient R -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : quotient R,
quotient_ump&#39;&#39; B (quotient_ump&#39; B f) x = f x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> quotient_ind_prop&#39;;[<span class="bp">exact</span> _|<span class="bp">reflexivity</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Missing</span>

<span class="sd">  The equivalence with VVquotient [A//R].</span>

<span class="sd">  This should lead to the unnamed theorem:</span>

<span class="sd">  10.1.10. Equivalence relations are effective and there is an equivalence [A/R&lt;~&gt;A//R]. *)</span>

  <span class="sd">(**</span>
<span class="sd">  The theory of canonical quotients is developed by C.Cohen:</span>
<span class="sd">  http://perso.crans.org/cohen/work/quotients/</span>
<span class="sd"> *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Equiv</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Functoriality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk112"><span class="kn">Definition</span> <span class="nf">quotient_functor</span>
             {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : Relation A) {<span class="nv">sR</span>: is_mere_relation _ R}
             {<span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">S</span> : Relation B) {<span class="nv">sS</span>: is_mere_relation _ S}
             (<span class="nv">f</span> : A -&gt; B) (<span class="nv">fresp</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, R x y -&gt; S (f x) (f y))
  : quotient R -&gt; quotient S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y -&gt; S (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient R -&gt; quotient S</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk113"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y -&gt; S (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient R -&gt; quotient S</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk114"><span class="nb">refine</span> (quotient_rec R (class_of S o f) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y -&gt; S (f x) (f y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A,
R x y -&gt; class_of S (f x) = class_of S (f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk115"><span class="nb">intros</span> x y r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y -&gt; S (f x) (f y)</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of S (f x) = class_of S (f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> related_classes_eq, fresp, r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : Relation A) {<span class="nv">sR</span>: is_mere_relation _ R}
          {<span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">S</span> : Relation B) {<span class="nv">sS</span>: is_mere_relation _ S}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk116">#[export] <span class="kn">Instance</span> <span class="nf">quotient_functor_isequiv</span>
             (<span class="nv">f</span> : A -&gt; B) (<span class="nv">fresp</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, R x y &lt;-&gt; S (f x) (f y))
             `{IsEquiv _ _ f}
  : IsEquiv (quotient_functor R S f (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; fst (fresp x y))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (quotient_functor R S f
     (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt; fst (fresp x y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk117"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (quotient_functor R S f
     (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt; fst (fresp x y)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk118"><span class="nb">simple refine</span> (isequiv_adjointify _ (quotient_functor S R f^-<span class="mi">1</span> _)
                               _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : B, S x y -&gt; R (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk119" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk119"><hr></label><div class="goal-conclusion">quotient_functor R S f
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt; fst (fresp x y))
o quotient_functor S R f^-<span class="mi">1</span> <span class="nl">?fresp</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="quotient-v-chk11a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk11a"><hr></label><div class="goal-conclusion">quotient_functor S R f^-<span class="mi">1</span> <span class="nl">?fresp</span>
o quotient_functor R S f
    (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt; fst (fresp x y)) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk11b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : B, S x y -&gt; R (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk11c"><span class="nb">intros</span> u v s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>S u v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk11d"><span class="nb">apply</span> (snd (fresp _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>u, v</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>S u v</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (f (f^-<span class="mi">1</span> u)) (f (f^-<span class="mi">1</span> v))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">abstract</span> (<span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> eisretr; <span class="bp">exact</span> s).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk11e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient_functor R S f
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt; fst (fresp x y))
o quotient_functor S R f^-<span class="mi">1</span>
    (<span class="kr">fun</span> (<span class="nv">u</span> <span class="nv">v</span> : B) (<span class="nv">s</span> : S u v) =&gt;
     snd (fresp (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v))
       (quotient_functor_isequiv_subproof f H u v s)) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk11f"><span class="nb">intros</span> x; <span class="nb">revert</span> x; <span class="nb">simple refine</span> (quotient_ind S _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : B,
(<span class="kr">fun</span> <span class="nv">q</span> : quotient S =&gt;
 quotient_functor R S f
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : A =&gt; fst (fresp x0 y))
   (quotient_functor S R f^-<span class="mi">1</span>
      (<span class="kr">fun</span> (<span class="nv">u</span> <span class="nv">v</span> : B) (<span class="nv">s</span> : S u v) =&gt;
       snd (fresp (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v))
         (quotient_functor_isequiv_subproof f H u v s))
      q) = q) (class_of S x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk120" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk120"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : B) (<span class="nv">H0</span> : S x y),
transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient S =&gt;
   quotient_functor R S f
     (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y0</span> : A =&gt; fst (fresp x0 y0))
     (quotient_functor S R f^-<span class="mi">1</span>
        (<span class="kr">fun</span> (<span class="nv">u</span> <span class="nv">v</span> : B) (<span class="nv">s</span> : S u v) =&gt;
         snd (fresp (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v))
           (quotient_functor_isequiv_subproof f H u v
              s)) q) = q) 
  (related_classes_eq S H0) 
  (<span class="nl">?dclass</span> x) = <span class="nl">?dclass</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk121">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : B,
(<span class="kr">fun</span> <span class="nv">q</span> : quotient S =&gt;
 quotient_functor R S f
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : A =&gt; fst (fresp x0 y))
   (quotient_functor S R f^-<span class="mi">1</span>
      (<span class="kr">fun</span> (<span class="nv">u</span> <span class="nv">v</span> : B) (<span class="nv">s</span> : S u v) =&gt;
       snd (fresp (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v))
         (quotient_functor_isequiv_subproof f H u v s))
      q) = q) (class_of S x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk122"><span class="nb">intros</span> b; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of S (f (f^-<span class="mi">1</span> b)) = class_of S b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk123">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : B) (<span class="nv">H0</span> : S x y),
transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient S =&gt;
   quotient_functor R S f
     (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y0</span> : A =&gt; fst (fresp x0 y0))
     (quotient_functor S R f^-<span class="mi">1</span>
        (<span class="kr">fun</span> (<span class="nv">u</span> <span class="nv">v</span> : B) (<span class="nv">s</span> : S u v) =&gt;
         snd (fresp (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v))
           (quotient_functor_isequiv_subproof f H u v
              s)) q) = q) (related_classes_eq S H0)
  ((<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
    ap (class_of S) (eisretr f b)
    :
    (<span class="kr">fun</span> <span class="nv">q</span> : quotient S =&gt;
     quotient_functor R S f
       (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y0</span> : A =&gt; fst (fresp x0 y0))
       (quotient_functor S R f^-<span class="mi">1</span>
          (<span class="kr">fun</span> (<span class="nv">u</span> <span class="nv">v</span> : B) (<span class="nv">s</span> : S u v) =&gt;
           snd (fresp (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v))
             (quotient_functor_isequiv_subproof f H u
                v s)) q) = q) (class_of S b)) x) =
(<span class="kr">fun</span> <span class="nv">b</span> : B =&gt;
 ap (class_of S) (eisretr f b)
 :
 (<span class="kr">fun</span> <span class="nv">q</span> : quotient S =&gt;
  quotient_functor R S f
    (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y0</span> : A =&gt; fst (fresp x0 y0))
    (quotient_functor S R f^-<span class="mi">1</span>
       (<span class="kr">fun</span> (<span class="nv">u</span> <span class="nv">v</span> : B) (<span class="nv">s</span> : S u v) =&gt;
        snd (fresp (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v))
          (quotient_functor_isequiv_subproof f H u v s))
       q) = q) (class_of S b)) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk124">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">quotient_functor S R f^-<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">u</span> <span class="nv">v</span> : B) (<span class="nv">s</span> : S u v) =&gt;
   snd (fresp (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v))
     (quotient_functor_isequiv_subproof f H u v s))
o quotient_functor R S f
    (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt; fst (fresp x y)) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk125"><span class="nb">intros</span> x; <span class="nb">revert</span> x; <span class="nb">simple refine</span> (quotient_ind R _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
(<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
 quotient_functor S R f^-<span class="mi">1</span>
   (<span class="kr">fun</span> (<span class="nv">u</span> <span class="nv">v</span> : B) (<span class="nv">s</span> : S u v) =&gt;
    snd (fresp (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v))
      (quotient_functor_isequiv_subproof f H u v s))
   (quotient_functor R S f
      (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : A =&gt; fst (fresp x0 y)) q) = q)
  (class_of R x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk126" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk126"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H0</span> : R x y),
transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
   quotient_functor S R f^-<span class="mi">1</span>
     (<span class="kr">fun</span> (<span class="nv">u</span> <span class="nv">v</span> : B) (<span class="nv">s</span> : S u v) =&gt;
      snd (fresp (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v))
        (quotient_functor_isequiv_subproof f H u v s))
     (quotient_functor R S f
        (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y0</span> : A =&gt; fst (fresp x0 y0)) q) = q)
  (related_classes_eq R H0) 
  (<span class="nl">?dclass</span> x) = <span class="nl">?dclass</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk127">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
(<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
 quotient_functor S R f^-<span class="mi">1</span>
   (<span class="kr">fun</span> (<span class="nv">u</span> <span class="nv">v</span> : B) (<span class="nv">s</span> : S u v) =&gt;
    snd (fresp (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v))
      (quotient_functor_isequiv_subproof f H u v s))
   (quotient_functor R S f
      (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y</span> : A =&gt; fst (fresp x0 y)) q) = q)
  (class_of R x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk128"><span class="nb">intros</span> a; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R (f^-<span class="mi">1</span> (f a)) = class_of R a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk129">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>S</var><span class="hyp-type"><b>: </b><span>Relation B</span></span></span><br><span><var>sS</var><span class="hyp-type"><b>: </b><span>is_mere_relation B S</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>fresp</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y &lt;-&gt; S (f x) (f y)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H0</span> : R x y),
transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
   quotient_functor S R f^-<span class="mi">1</span>
     (<span class="kr">fun</span> (<span class="nv">u</span> <span class="nv">v</span> : B) (<span class="nv">s</span> : S u v) =&gt;
      snd (fresp (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v))
        (quotient_functor_isequiv_subproof f H u v s))
     (quotient_functor R S f
        (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y0</span> : A =&gt; fst (fresp x0 y0)) q) = q)
  (related_classes_eq R H0)
  ((<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    ap (class_of R) (eissect f a)
    :
    (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
     quotient_functor S R f^-<span class="mi">1</span>
       (<span class="kr">fun</span> (<span class="nv">u</span> <span class="nv">v</span> : B) (<span class="nv">s</span> : S u v) =&gt;
        snd (fresp (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v))
          (quotient_functor_isequiv_subproof f H u v s))
       (quotient_functor R S f
          (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y0</span> : A =&gt; fst (fresp x0 y0)) q) = q)
      (class_of R a)) x) =
(<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
 ap (class_of R) (eissect f a)
 :
 (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
  quotient_functor S R f^-<span class="mi">1</span>
    (<span class="kr">fun</span> (<span class="nv">u</span> <span class="nv">v</span> : B) (<span class="nv">s</span> : S u v) =&gt;
     snd (fresp (f^-<span class="mi">1</span> u) (f^-<span class="mi">1</span> v))
       (quotient_functor_isequiv_subproof f H u v s))
    (quotient_functor R S f
       (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y0</span> : A =&gt; fst (fresp x0 y0)) q) = q)
   (class_of R a)) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">quotient_functor_equiv</span>
             (<span class="nv">f</span> : A -&gt; B) (<span class="nv">fresp</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, R x y &lt;-&gt; S (f x) (f y))
             `{IsEquiv _ _ f}
  : quotient R &lt;~&gt; quotient S
    := Build_Equiv _ _
         (quotient_functor R S f (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; fst (fresp x y))) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">quotient_functor_equiv&#39;</span>
             (<span class="nv">f</span> : A &lt;~&gt; B) (<span class="nv">fresp</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, R x y &lt;-&gt; S (f x) (f y))
  : quotient R &lt;~&gt; quotient S
    := quotient_functor_equiv f fresp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Functoriality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Kernel</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Quotients of kernels of maps to sets give a surjection/mono factorization. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">fs</span> : Funext}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A function we want to factor. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{IsHSet B} (f : A -&gt; B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A mere relation equivalent to its kernel. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">R</span> : Relation A) {<span class="nv">sR</span> : is_mere_relation _ R}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">is_ker</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, f x = f y &lt;~&gt; R x y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk12a"><span class="kn">Theorem</span> <span class="nf">quotient_kernel_factor</span>
  : <span class="kr">exists</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">e</span> : A -&gt; C) (<span class="nv">m</span> : C -&gt; B),
      IsHSet C * IsSurjection e * IsEmbedding m * (f = m o e).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{C : <span class="kt">Type</span> &amp;
{e : A -&gt; C &amp;
{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = m o e)}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk12b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{C : <span class="kt">Type</span> &amp;
{e : A -&gt; C &amp;
{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = m o e)}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk12c"><span class="nb">pose</span> (C := quotient R).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{C : <span class="kt">Type</span> &amp;
{e : A -&gt; C &amp;
{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = m o e)}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* We put this explicitly in the context so that typeclass resolution will pick it up. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk12d"><span class="nb">assert</span> (IsHSet C) <span class="bp">by</span> (<span class="nb">unfold</span> C; <span class="bp">exact</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{C : <span class="kt">Type</span> &amp;
{e : A -&gt; C &amp;
{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = m o e)}}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk12e"><span class="kr">exists</span> <span class="nv">C</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{e : A -&gt; C &amp;
{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; m (e x)))}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk12f"><span class="nb">pose</span> (e := class_of R).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{e : A -&gt; C &amp;
{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; m (e x)))}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk130"><span class="kr">exists</span> <span class="nv">e</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; m (e x)))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk131">transparent <span class="nb">assert</span> (m : (C -&gt; B)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C -&gt; B</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk132" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span><span class="nl">?Goal</span></span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br></div><label class="goal-separator" for="quotient-v-chk132"><hr></label><div class="goal-conclusion">{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; m (e x)))}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk133">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C -&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk134"><span class="nb">apply</span> quotient_ind <span class="kr">with</span> f; <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y),
transport (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B)
  (related_classes_eq R H) (f x) = f y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk135"><span class="nb">intros</span> x y H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B)
  (related_classes_eq R H) (f x) = f y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk136"><span class="nb">transitivity</span> (f x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B)
  (related_classes_eq R H) (f x) = f x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk137" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk137"><hr></label><div class="goal-conclusion">f x = f y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk138">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B)
  (related_classes_eq R H) (f x) = f x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_const.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk139">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = f y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((is_ker x y) ^-<span class="mi">1</span> H).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk13a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{m : C -&gt; B &amp;
IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; m (e x)))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk13b"><span class="kr">exists</span> <span class="nv">m</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet C * ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e *
IsEmbedding m * (f = (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; m (e x)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk13c"><span class="nb">split</span>;[<span class="nb">split</span>;[<span class="nb">split</span>|]|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet C</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk13d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br></div><label class="goal-separator" for="quotient-v-chk13d"><hr></label><div class="goal-conclusion">ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e</div></blockquote><input class="alectryon-extra-goal-toggle" id="quotient-v-chk13e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br></div><label class="goal-separator" for="quotient-v-chk13e"><hr></label><div class="goal-conclusion">IsEmbedding m</div></blockquote><input class="alectryon-extra-goal-toggle" id="quotient-v-chk13f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br></div><label class="goal-separator" for="quotient-v-chk13f"><hr></label><div class="goal-conclusion">f = (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; m (e x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk140">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet C</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk141">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ReflectiveSubuniverse.IsConnMap (Tr (-<span class="mi">1</span>)) e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> quotient_surjective.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk142">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk143"><span class="nb">intro</span> u.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (hfiber m u)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk144"><span class="nb">apply</span> hprop_allpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : hfiber m u, x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk145"><span class="nb">assert</span> (H : <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : C) (<span class="nv">p</span> : m x = u) (<span class="nv">p&#39;</span> : m y = u), x = y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : C, m x = u -&gt; m y = u -&gt; x = y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk146" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : C, m x = u -&gt; m y = u -&gt; x = y</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk146"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : hfiber m u, x = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk147">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : C, m x = u -&gt; m y = u -&gt; x = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk148"><span class="nb">simple refine</span> (quotient_ind R _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
(<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
 <span class="kr">forall</span> <span class="nv">y</span> : C, m q = u -&gt; m y = u -&gt; q = y)
  (class_of R x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk149" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk149"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y),
transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
   <span class="kr">forall</span> <span class="nv">y0</span> : C, m q = u -&gt; m y0 = u -&gt; q = y0)
  (related_classes_eq R H) 
  (<span class="nl">?dclass</span> x) = <span class="nl">?dclass</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk14a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
(<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
 <span class="kr">forall</span> <span class="nv">y</span> : C, m q = u -&gt; m y = u -&gt; q = y)
  (class_of R x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk14b"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
 <span class="kr">forall</span> <span class="nv">y</span> : C, m q = u -&gt; m y = u -&gt; q = y)
  (class_of R a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk14c"><span class="nb">simple refine</span> (quotient_ind R _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
(<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
 m (class_of R a) = u -&gt; m q = u -&gt; class_of R a = q)
  (class_of R x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="quotient-v-chk14d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="quotient-v-chk14d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y),
transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
   m (class_of R a) = u -&gt; m q = u -&gt; class_of R a = q)
  (related_classes_eq R H) 
  (<span class="nl">?dclass</span> x) = <span class="nl">?dclass</span> y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk14e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
(<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
 m (class_of R a) = u -&gt; m q = u -&gt; class_of R a = q)
  (class_of R x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk14f"><span class="nb">intros</span> a&#39; p p&#39;; <span class="nb">fold</span> e <span class="kr">in</span> p, p&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>m (e a) = u</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>m (e a&#39;) = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R a = class_of R a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk150">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>m (e a) = u</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>m (e a&#39;) = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">class_of R a = class_of R a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk151"><span class="nb">apply</span> related_classes_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>m (e a) = u</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>m (e a&#39;) = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk152"><span class="nb">refine</span> (is_ker a a&#39; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>m (e a) = u</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>m (e a&#39;) = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a = f a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk153"><span class="nb">change</span> (m (e a) = m (e a&#39;)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>m (e a) = u</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>m (e a&#39;) = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m (e a) = m (e a&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">              </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p @ p&#39;^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk154">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y),
transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
   m (class_of R a) = u -&gt; m q = u -&gt; class_of R a = q)
  (related_classes_eq R H)
  ((<span class="kr">fun</span> <span class="nv">a&#39;</span> : A =&gt;
    (<span class="kr">fun</span> (<span class="nv">p</span> : m (class_of R a) = u)
       (<span class="nv">p&#39;</span> : m (class_of R a&#39;) = u) =&gt;
     related_classes_eq R (is_ker a a&#39; (p @ p&#39;^)))
    :
    (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
     m (class_of R a) = u -&gt;
     m q = u -&gt; class_of R a = q) (class_of R a&#39;)) x) =
(<span class="kr">fun</span> <span class="nv">a&#39;</span> : A =&gt;
 (<span class="kr">fun</span> (<span class="nv">p</span> : m (class_of R a) = u)
    (<span class="nv">p&#39;</span> : m (class_of R a&#39;) = u) =&gt;
  related_classes_eq R (is_ker a a&#39; (p @ p&#39;^)))
 :
 (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
  m (class_of R a) = u -&gt; m q = u -&gt; class_of R a = q)
   (class_of R a&#39;)) y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk155">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y),
transport
  (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
   <span class="kr">forall</span> <span class="nv">y0</span> : C, m q = u -&gt; m y0 = u -&gt; q = y0)
  (related_classes_eq R H)
  ((<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    quotient_ind R
      (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
       m (class_of R a) = u -&gt;
       m q = u -&gt; class_of R a = q)
      (<span class="kr">fun</span> <span class="nv">a&#39;</span> : A =&gt;
       (<span class="kr">fun</span> (<span class="nv">p</span> : m (class_of R a) = u)
          (<span class="nv">p&#39;</span> : m (class_of R a&#39;) = u) =&gt;
        related_classes_eq R (is_ker a a&#39; (p @ p&#39;^)))
       :
       (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
        m (class_of R a) = u -&gt;
        m q = u -&gt; class_of R a = q) (class_of R a&#39;))
      (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> : A) (<span class="nv">H0</span> : R x0 y0) =&gt;
       path_ishprop
         (transport
            (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
             m (class_of R a) = u -&gt;
             m q = u -&gt; class_of R a = q)
            (related_classes_eq R H0)
            (<span class="kr">fun</span> (<span class="nv">p</span> : m (class_of R a) = u)
               (<span class="nv">p&#39;</span> : m (class_of R x0) = u) =&gt;
             related_classes_eq R
               (is_ker a x0 (p @ p&#39;^))))
         (<span class="kr">fun</span> (<span class="nv">p</span> : m (class_of R a) = u)
            (<span class="nv">p&#39;</span> : m (class_of R y0) = u) =&gt;
          related_classes_eq R (is_ker a y0 (p @ p&#39;^)))))
     x) =
(<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
 quotient_ind R
   (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
    m (class_of R a) = u -&gt;
    m q = u -&gt; class_of R a = q)
   (<span class="kr">fun</span> <span class="nv">a&#39;</span> : A =&gt;
    (<span class="kr">fun</span> (<span class="nv">p</span> : m (class_of R a) = u)
       (<span class="nv">p&#39;</span> : m (class_of R a&#39;) = u) =&gt;
     related_classes_eq R (is_ker a a&#39; (p @ p&#39;^)))
    :
    (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
     m (class_of R a) = u -&gt;
     m q = u -&gt; class_of R a = q) (class_of R a&#39;))
   (<span class="kr">fun</span> (<span class="nv">x0</span> <span class="nv">y0</span> : A) (<span class="nv">H0</span> : R x0 y0) =&gt;
    path_ishprop
      (transport
         (<span class="kr">fun</span> <span class="nv">q</span> : quotient R =&gt;
          m (class_of R a) = u -&gt;
          m q = u -&gt; class_of R a = q)
         (related_classes_eq R H0)
         (<span class="kr">fun</span> (<span class="nv">p</span> : m (class_of R a) = u)
            (<span class="nv">p&#39;</span> : m (class_of R x0) = u) =&gt;
          related_classes_eq R (is_ker a x0 (p @ p&#39;^))))
      (<span class="kr">fun</span> (<span class="nv">p</span> : m (class_of R a) = u)
         (<span class="nv">p&#39;</span> : m (class_of R y0) = u) =&gt;
       related_classes_eq R (is_ker a y0 (p @ p&#39;^)))))
  y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk156">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : C, m x = u -&gt; m y = u -&gt; x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : hfiber m u, x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk157"><span class="nb">intros</span> [x p] [y p&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : C, m x = u -&gt; m y = u -&gt; x = y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>m x = u</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>m y = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x; p) = (y; p&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk158"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br><span><var>u</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : C, m x = u -&gt; m y = u -&gt; x = y</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>m x = u</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>m y = u</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (H x y p p&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="quotient-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="quotient-v-chk159">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>fs</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>Relation A</span></span></span><br><span><var>sR</var><span class="hyp-type"><b>: </b><span>is_mere_relation A R</span></span></span><br><span><var>is_ker</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, f x = f y &lt;~&gt; R x y</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span>quotient R</span></span><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsHSet C</span></span></span><br><span><var>e</var><span><span class="hyp-body"><b>:= </b><span>class_of R</span></span><span class="hyp-type"><b>: </b><span>A -&gt; quotient R</span></span></span></span><br><span><var>m</var><span><span class="hyp-body"><b>:= </b><span>quotient_ind R (<span class="kr">fun</span> <span class="nv">_</span> : quotient R =&gt; B) f
  (<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">H</span> : R x y) =&gt;
   transport_const (related_classes_eq R H) (f x) @
   (is_ker x y)^-<span class="mi">1</span> H)</span></span><span class="hyp-type"><b>: </b><span>C -&gt; B</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; m (e x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Kernel</span>.</span></span></pre>
</div>
</div></body>
</html>
